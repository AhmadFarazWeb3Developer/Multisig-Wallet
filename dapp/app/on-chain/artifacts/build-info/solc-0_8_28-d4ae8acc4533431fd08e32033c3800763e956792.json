{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-d4ae8acc4533431fd08e32033c3800763e956792",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/libraries/MultiSend.sol": "project/contracts/libraries/MultiSend.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/libraries/MultiSend.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title Multi Send - Allows to batch multiple transactions into one.\r\n * @author Nick Dodson - <nick.dodson@consensys.net>\r\n * @author Gonçalo Sá - <goncalo.sa@consensys.net>\r\n * @author Stefan George - @Georgi87\r\n * @author Richard Meissner - @rmeissner\r\n */\r\ncontract MultiSend {\r\n    address private immutable MULTISEND_SINGLETON;\r\n\r\n    constructor() {\r\n        MULTISEND_SINGLETON = address(this);\r\n    }\r\n\r\n    /**\r\n     * @dev Sends multiple transactions and reverts all if one fails.\r\n     * @param transactions Encoded transactions. Each transaction is encoded as a packed bytes of\r\n     *                     operation as a uint8 with 0 for a call or 1 for a delegatecall (=> 1 byte),\r\n     *                     to as a address (=> 20 bytes),\r\n     *                     value as a uint256 (=> 32 bytes),\r\n     *                     data length as a uint256 (=> 32 bytes),\r\n     *                     data as bytes.\r\n     *                     see abi.encodePacked for more information on packed encoding\r\n     * @notice This method is payable as delegatecalls keep the msg.value from the previous call\r\n     *         If the calling method (e.g. execTransaction) received ETH this would revert otherwise\r\n     */\r\n    function multiSend(bytes memory transactions) public payable {\r\n        require(address(this) != MULTISEND_SINGLETON, \"MultiSend should only be called via delegatecall\");\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let length := mload(transactions)\r\n            let i := 0x20\r\n            for {\r\n                // Pre block is not used in \"while mode\"\r\n            } lt(i, length) {\r\n                // Post block is not used in \"while mode\"\r\n            } {\r\n                // First byte of the data is the operation.\r\n                // We shift by 248 bits (256 - 8 [operation byte]) right, since mload will always load 32 bytes (a word).\r\n                // This will also zero out unused data.\r\n                let operation := shr(0xf8, mload(add(transactions, i)))\r\n                // We offset the load address by 1 byte (operation byte)\r\n                // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\r\n                let to := shr(0x60, mload(add(transactions, add(i, 0x01))))\r\n                // Defaults `to` to `address(this)` if `address(0)` is provided.\r\n                to := or(to, mul(iszero(to), address()))\r\n                // We offset the load address by 21 byte (operation byte + 20 address bytes)\r\n                let value := mload(add(transactions, add(i, 0x15)))\r\n                // We offset the load address by 53 byte (operation byte + 20 address bytes + 32 value bytes)\r\n                let dataLength := mload(add(transactions, add(i, 0x35)))\r\n                // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\r\n                let data := add(transactions, add(i, 0x55))\r\n                let success := 0\r\n                switch operation\r\n                case 0 {\r\n                    success := call(gas(), to, value, data, dataLength, 0, 0)\r\n                }\r\n                case 1 {\r\n                    success := delegatecall(gas(), to, data, dataLength, 0, 0)\r\n                }\r\n                if iszero(success) {\r\n                    let ptr := mload(0x40)\r\n                    returndatacopy(ptr, 0, returndatasize())\r\n                    revert(ptr, returndatasize())\r\n                }\r\n                // Next entry starts at 85 byte + data length\r\n                i := add(i, add(0x55, dataLength))\r\n            }\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n    }\r\n}\r\n"
      }
    }
  }
}