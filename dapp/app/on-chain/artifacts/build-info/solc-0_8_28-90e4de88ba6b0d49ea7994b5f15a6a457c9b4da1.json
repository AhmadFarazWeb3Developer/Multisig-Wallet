{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-90e4de88ba6b0d49ea7994b5f15a6a457c9b4da1",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/handler/HandlerContext.sol": "project/contracts/handler/HandlerContext.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/handler/HandlerContext.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {ISafe} from \"../interfaces/ISafe.sol\";\r\n\r\n/**\r\n * @title Handler Context - Allows the fallback handler to extract additional context from the calldata\r\n * @dev The fallback manager appends the following context to the calldata:\r\n *      1. Fallback manager caller address (non-padded)\r\n * based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/f8cc8b844a9f92f63dc55aa581f7d643a1bc5ac1/contracts/metatx/ERC2771Context.sol\r\n * @author Richard Meissner - @rmeissner\r\n */\r\nabstract contract HandlerContext {\r\n    /**\r\n     * @dev The storage slot used for storing the currently configured fallback handler address.\r\n     *      Precomputed value of: `keccak256(\"fallback_manager.handler.address\")`.\r\n     */\r\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\r\n\r\n    /**\r\n     * @notice A modifier that reverts if not called by a Safe as a fallback handler.\r\n     * @dev Note that this modifier does a **best effort** attempt at not allowing calls that are\r\n     *      not as a fallback call, but it still can be tricked. It is suitable for use cases such\r\n     *      making a best effort attempt to disallow ERC-721 and ERC-1155 token transfers to the\r\n     *      fallback handler contract.\r\n     */\r\n    modifier onlyFallback() {\r\n        _requireFallback();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Implementation of the {onlySafeFallback} modifier check that the current call is a Safe\r\n     *      fallback call, and the contract is not called directly. Note that this is only a **best\r\n     *      effort** check and may generate false positives under certain conditions.\r\n     */\r\n    function _requireFallback() internal view {\r\n        bytes memory storageData = ISafe(payable(msg.sender)).getStorageAt(uint256(FALLBACK_HANDLER_STORAGE_SLOT), 1);\r\n        address fallbackHandler = abi.decode(storageData, (address));\r\n        require(fallbackHandler == address(this), \"not a fallback call\");\r\n    }\r\n\r\n    /**\r\n     * @notice Allows fetching the original caller address.\r\n     * @dev This is only reliable in combination with a FallbackManager that supports this (e.g. Safe contract >=1.3.0).\r\n     *      When using this functionality make sure that the linked _manager (aka msg.sender) supports this.\r\n     *      This function does not rely on a trusted forwarder. Use the returned value only to\r\n     *      check information against the calling manager.\r\n     * @return sender Original caller address.\r\n     */\r\n    function _msgSender() internal pure returns (address sender) {\r\n        require(msg.data.length >= 20, \"Invalid calldata length\");\r\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the FallbackManager address\r\n     * @return Fallback manager address\r\n     */\r\n    function _manager() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n"
      },
      "project/contracts/interfaces/IFallbackManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title IFallbackManager - A contract interface managing fallback calls made to this contract.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IFallbackManager {\r\n    event ChangedFallbackHandler(address indexed handler);\r\n\r\n    /**\r\n     * @notice Set Fallback Handler to `handler` for the Safe.\r\n     * @dev 1. Only fallback calls without value and with data will be forwarded.\r\n     *      2. Changing the fallback handler can only be done via a Safe transaction.\r\n     *      3. Cannot be set to the Safe itself.\r\n     *      4. IMPORTANT! SECURITY RISK! The fallback handler can be set to any address and all the calls will be forwarded to it,\r\n     *         bypassing all the Safe's access control mechanisms. When setting the fallback handler, make sure to check the address\r\n     *         is a trusted contract and if it supports state changes, it implements the necessary checks.\r\n     * @param handler contract to handle fallback calls.\r\n     */\r\n    function setFallbackHandler(address handler) external;\r\n\r\n    /**\r\n     * @notice Forwards all calls to the fallback handler if set.\r\n     *         Returns empty data if no handler is set.\r\n     * @dev Appends the non-padded caller address to the calldata to be optionally used in the handler\r\n     *      The handler can make use of {HandlerContext} to extract the address.\r\n     *      This is done because in the next call frame the `msg.sender` will be {FallbackManager}'s address\r\n     *      and having the original caller address may enable additional verification scenarios.\r\n     */\r\n    fallback() external;\r\n}\r\n"
      },
      "project/contracts/interfaces/IGuardManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\n/* solhint-disable one-contract-per-file */\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title IGuardManager - A contract interface managing transaction guards which perform pre and post-checks on Safe transactions.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IGuardManager {\r\n    event ChangedGuard(address indexed guard);\r\n\r\n    /**\r\n     * @dev Set a guard that checks transactions before execution\r\n     *      This can only be done via a Safe transaction.\r\n     *      ⚠️ IMPORTANT: Since a guard has full power to block Safe transaction execution,\r\n     *        a broken guard can cause a denial of service for the Safe. Make sure to carefully\r\n     *        audit the guard code and design recovery mechanisms.\r\n     * @notice Set Transaction Guard `guard` for the Safe. Make sure you trust the guard.\r\n     * @param guard The address of the guard to be used or the 0 address to disable the guard\r\n     */\r\n    function setGuard(address guard) external;\r\n}\r\n"
      },
      "project/contracts/interfaces/IModuleManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\nimport {Enum} from \"../libraries/Enum.sol\";\r\n\r\n/**\r\n * @title IModuleManager - An interface of contract managing Safe modules\r\n * @notice Modules are extensions with unlimited access to a Safe that can be added to a Safe by its owners.\r\n           ⚠️ WARNING: Modules are a security risk since they can execute arbitrary transactions, \r\n           so only trusted and audited modules should be added to a Safe. A malicious module can\r\n           completely takeover a Safe.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IModuleManager {\r\n    event EnabledModule(address indexed module);\r\n    event DisabledModule(address indexed module);\r\n    event ExecutionFromModuleSuccess(address indexed module);\r\n    event ExecutionFromModuleFailure(address indexed module);\r\n    event ChangedModuleGuard(address indexed moduleGuard);\r\n\r\n    /**\r\n     * @notice Enables the module `module` for the Safe.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param module Module to be whitelisted.\r\n     */\r\n    function enableModule(address module) external;\r\n\r\n    /**\r\n     * @notice Disables the module `module` for the Safe.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param prevModule Previous module in the modules linked list.\r\n     * @param module Module to be removed.\r\n     */\r\n    function disableModule(address prevModule, address module) external;\r\n\r\n    /**\r\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token)\r\n     * @param to Destination address of module transaction.\r\n     * @param value Ether value of module transaction.\r\n     * @param data Data payload of module transaction.\r\n     * @param operation Operation type of module transaction.\r\n     * @return success Boolean flag indicating if the call succeeded.\r\n     */\r\n    function execTransactionFromModule(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation\r\n    ) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token) and return data\r\n     * @param to Destination address of module transaction.\r\n     * @param value Ether value of module transaction.\r\n     * @param data Data payload of module transaction.\r\n     * @param operation Operation type of module transaction.\r\n     * @return success Boolean flag indicating if the call succeeded.\r\n     * @return returnData Data returned by the call.\r\n     */\r\n    function execTransactionFromModuleReturnData(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation\r\n    ) external returns (bool success, bytes memory returnData);\r\n\r\n    /**\r\n     * @notice Returns if a module is enabled\r\n     * @return True if the module is enabled\r\n     */\r\n    function isModuleEnabled(address module) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns an array of modules.\r\n     *         If all entries fit into a single page, the next pointer will be 0x1.\r\n     *         If another page is present, next will be the last element of the returned array.\r\n     * @param start Start of the page. Has to be a module or start pointer (0x1 address)\r\n     * @param pageSize Maximum number of modules that should be returned. Has to be > 0\r\n     * @return array Array of modules.\r\n     * @return next Start of the next page.\r\n     */\r\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next);\r\n\r\n    /**\r\n     * @dev Set a module guard that checks transactions initiated by the module before execution\r\n     *      This can only be done via a Safe transaction.\r\n     *      ⚠️ IMPORTANT: Since a module guard has full power to block Safe transaction execution initiated via a module,\r\n     *        a broken module guard can cause a denial of service for the Safe modules. Make sure to carefully\r\n     *        audit the module guard code and design recovery mechanisms.\r\n     * @notice Set Module Guard `moduleGuard` for the Safe. Make sure you trust the module guard.\r\n     * @param moduleGuard The address of the module guard to be used or the zero address to disable the module guard.\r\n     */\r\n    function setModuleGuard(address moduleGuard) external;\r\n}\r\n"
      },
      "project/contracts/interfaces/INativeCurrencyPaymentFallback.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title Native Currency Payment Fallback Interface\r\n * @notice An interface to a contract that can receive native currency payments.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface INativeCurrencyPaymentFallback {\r\n    event SafeReceived(address indexed sender, uint256 value);\r\n\r\n    /**\r\n     * @notice Receive function accepts native currency transactions.\r\n     * @dev Emits an event with sender and received value.\r\n     */\r\n    receive() external payable;\r\n}\r\n"
      },
      "project/contracts/interfaces/IOwnerManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title IOwnerManager - Interface for contract which manages Safe owners and a threshold to authorize transactions.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IOwnerManager {\r\n    event AddedOwner(address indexed owner);\r\n    event RemovedOwner(address indexed owner);\r\n    event ChangedThreshold(uint256 threshold);\r\n\r\n    /**\r\n     * @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param owner New owner address.\r\n     * @param _threshold New threshold.\r\n     */\r\n    function addOwnerWithThreshold(address owner, uint256 _threshold) external;\r\n\r\n    /**\r\n     * @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param prevOwner Owner that pointed to the owner to be removed in the linked list\r\n     * @param owner Owner address to be removed.\r\n     * @param _threshold New threshold.\r\n     */\r\n    function removeOwner(address prevOwner, address owner, uint256 _threshold) external;\r\n\r\n    /**\r\n     * @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param prevOwner Owner that pointed to the owner to be replaced in the linked list\r\n     * @param oldOwner Owner address to be replaced.\r\n     * @param newOwner New owner address.\r\n     */\r\n    function swapOwner(address prevOwner, address oldOwner, address newOwner) external;\r\n\r\n    /**\r\n     * @notice Changes the threshold of the Safe to `_threshold`.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param _threshold New threshold.\r\n     */\r\n    function changeThreshold(uint256 _threshold) external;\r\n\r\n    /**\r\n     * @notice Returns the number of required confirmations for a Safe transaction aka the threshold.\r\n     * @return Threshold number.\r\n     */\r\n    function getThreshold() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns if `owner` is an owner of the Safe.\r\n     * @return Boolean if `owner` is an owner of the Safe.\r\n     */\r\n    function isOwner(address owner) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns a list of Safe owners.\r\n     * @return Array of Safe owners.\r\n     */\r\n    function getOwners() external view returns (address[] memory);\r\n}\r\n"
      },
      "project/contracts/interfaces/ISafe.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {Enum} from \"./../libraries/Enum.sol\";\r\nimport {IFallbackManager} from \"./IFallbackManager.sol\";\r\nimport {IGuardManager} from \"./IGuardManager.sol\";\r\nimport {IModuleManager} from \"./IModuleManager.sol\";\r\nimport {INativeCurrencyPaymentFallback} from \"./INativeCurrencyPaymentFallback.sol\";\r\nimport {IOwnerManager} from \"./IOwnerManager.sol\";\r\nimport {IStorageAccessible} from \"./IStorageAccessible.sol\";\r\n\r\n/**\r\n * @title ISafe - A multisignature wallet interface with support for confirmations using signed messages based on EIP-712.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface ISafe is INativeCurrencyPaymentFallback, IModuleManager, IGuardManager, IOwnerManager, IFallbackManager, IStorageAccessible {\r\n    event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);\r\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\r\n    event SignMsg(bytes32 indexed msgHash);\r\n    event ExecutionFailure(bytes32 indexed txHash, uint256 payment);\r\n    event ExecutionSuccess(bytes32 indexed txHash, uint256 payment);\r\n\r\n    /**\r\n     * @notice Sets an initial storage of the Safe contract.\r\n     * @dev This method can only be called once.\r\n     *      If a proxy was created without setting up, anyone can call setup and claim the proxy.\r\n     *      This method emits a {SafeSetup} event with the setup parameters instead of reading from storage,\r\n     *      which may be inaccurate if the delegate call to `to` modifies the owners, threshold or fallback handler.\r\n     * @param _owners List of Safe owners.\r\n     * @param _threshold Number of required confirmations for a Safe transaction.\r\n     * @param to Contract address for optional delegate call.\r\n     * @param data Data payload for optional delegate call.\r\n     * @param fallbackHandler Handler for fallback calls to this contract\r\n     * @param paymentToken Token that should be used for the payment (0 is ETH)\r\n     * @param payment Value that should be paid\r\n     * @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)\r\n     */\r\n    function setup(\r\n        address[] calldata _owners,\r\n        uint256 _threshold,\r\n        address to,\r\n        bytes calldata data,\r\n        address fallbackHandler,\r\n        address paymentToken,\r\n        uint256 payment,\r\n        address payable paymentReceiver\r\n    ) external;\r\n\r\n    /** @notice Executes a `operation` {0: Call, 1: DelegateCall} transaction to `to` with `value` (Native Currency)\r\n     *          and pays `gasPrice` * `gasLimit` in `gasToken` token to `refundReceiver`.\r\n     * @dev The fees are always transferred, even if the user transaction fails.\r\n     *      This method doesn't perform any sanity check of the transaction, such as:\r\n     *      - if the contract at `to` address has code or not\r\n     *      - if the `gasToken` is a contract or not\r\n     *      It is the responsibility of the caller to perform such checks.\r\n     * @param to Destination address of Safe transaction.\r\n     * @param value Ether value of Safe transaction.\r\n     * @param data Data payload of Safe transaction.\r\n     * @param operation Operation type of Safe transaction.\r\n     * @param safeTxGas Gas that should be used for the Safe transaction.\r\n     * @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\r\n     * @param gasPrice Gas price that should be used for the payment calculation.\r\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n     * @param signatures Signature data that should be verified.\r\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\r\n     * @return success Boolean indicating transaction's success.\r\n     */\r\n    function execTransaction(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address payable refundReceiver,\r\n        bytes memory signatures\r\n    ) external payable returns (bool success);\r\n\r\n    /**\r\n     * @notice Checks whether the signature provided is valid for the provided data and hash and executor. Reverts otherwise.\r\n     * @param executor Address that executes the transaction.\r\n     *        ⚠️⚠️⚠️ Make sure that the executor address is a legitimate executor.\r\n     *        Incorrectly passed the executor might reduce the threshold by 1 signature. ⚠️⚠️⚠️\r\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\r\n     * @param signatures Signature data that should be verified.\r\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\r\n     */\r\n    function checkSignatures(address executor, bytes32 dataHash, bytes memory signatures) external view;\r\n\r\n    /**\r\n     * @notice Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.\r\n     * @dev Since the EIP-1271 does an external call, be mindful of reentrancy attacks.\r\n     * @param executor Address that executes the transaction.\r\n     *        ⚠️⚠️⚠️ Make sure that the executor address is a legitimate executor.\r\n     *        Incorrectly passed the executor might reduce the threshold by 1 signature. ⚠️⚠️⚠️\r\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\r\n     * @param signatures Signature data that should be verified.\r\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\r\n     * @param requiredSignatures Amount of required valid signatures.\r\n     */\r\n    function checkNSignatures(address executor, bytes32 dataHash, bytes memory signatures, uint256 requiredSignatures) external view;\r\n\r\n    /**\r\n     * @notice Marks hash `hashToApprove` as approved.\r\n     * @dev This can be used with a pre-approved hash transaction signature.\r\n     *      IMPORTANT: The approved hash stays approved forever. There's no revocation mechanism, so it behaves similarly to ECDSA signatures\r\n     * @param hashToApprove The hash to mark as approved for signatures that are verified by this contract.\r\n     */\r\n    function approveHash(bytes32 hashToApprove) external;\r\n\r\n    /**\r\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\r\n     * @return bytes32 The domain separator hash.\r\n     */\r\n    function domainSeparator() external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Returns transaction hash to be signed by owners.\r\n     * @param to Destination address.\r\n     * @param value Ether value.\r\n     * @param data Data payload.\r\n     * @param operation Operation type.\r\n     * @param safeTxGas Gas that should be used for the safe transaction.\r\n     * @param baseGas Gas costs for data used to trigger the safe transaction.\r\n     * @param gasPrice Maximum gas price that should be used for this transaction.\r\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n     * @param _nonce Transaction nonce.\r\n     * @return Transaction hash.\r\n     */\r\n    function getTransactionHash(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address refundReceiver,\r\n        uint256 _nonce\r\n    ) external view returns (bytes32);\r\n\r\n    /**\r\n     * External getter function for state variables.\r\n     */\r\n\r\n    /**\r\n     * @notice Returns the version of the Safe contract.\r\n     * @return Version string.\r\n     */\r\n    // solhint-disable-next-line\r\n    function VERSION() external view returns (string memory);\r\n\r\n    /**\r\n     * @notice Returns the nonce of the Safe contract.\r\n     * @return Nonce.\r\n     */\r\n    function nonce() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns a uint if the messageHash is signed by the owner.\r\n     * @param messageHash Hash of message that should be checked.\r\n     * @return Number denoting if an owner signed the hash.\r\n     */\r\n    function signedMessages(bytes32 messageHash) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns a uint if the messageHash is approved by the owner.\r\n     * @param owner Owner address that should be checked.\r\n     * @param messageHash Hash of message that should be checked.\r\n     * @return Number denoting if an owner approved the hash.\r\n     */\r\n    function approvedHashes(address owner, bytes32 messageHash) external view returns (uint256);\r\n}\r\n"
      },
      "project/contracts/interfaces/IStorageAccessible.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title Storage Accessible Interface\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IStorageAccessible {\r\n    /**\r\n     * @notice Reads `length` bytes of storage in the current contract\r\n     * @param offset The offset in the current contract's storage in words to start reading from.\r\n     * @param length The number of words (32 bytes) of data to read.\r\n     * @return The bytes that were read.\r\n     */\r\n    function getStorageAt(uint256 offset, uint256 length) external view returns (bytes memory);\r\n\r\n    /**\r\n     * @notice Performs a `DELEGATECALL` to a `targetContract` in the context of self.\r\n     * @dev Internally reverts execution to avoid side effects (making it effectively static).\r\n     *      This method reverts with data equal to `abi.encodePacked(uint256(success), uint256(response.length), bytes(response))`.\r\n     *      Specifically, the return data after a call to this method will be:\r\n     *      `success:uint256 || response.length:uint256 || response:bytes`.\r\n     * @param targetContract Address of the contract containing the code to execute.\r\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\r\n     */\r\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external;\r\n}\r\n"
      },
      "project/contracts/libraries/Enum.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title Enum - Collection of enums used in Safe Smart Account contracts.\r\n * @author @safe-global/safe-protocol\r\n */\r\nlibrary Enum {\r\n    enum Operation {\r\n        Call,\r\n        DelegateCall\r\n    }\r\n}\r\n"
      }
    }
  }
}