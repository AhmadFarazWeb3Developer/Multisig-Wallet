{"_format":"hh3-sol-build-info-output-1","id":"solc-0_8_28-70ac3f3b2aeff0394c71a069ffcb01d0952ec669","output":{"contracts":{"project/contracts/interfaces/IFallbackManager.sol":{"IFallbackManager":{"abi":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"handler","type":"address"}],"name":"ChangedFallbackHandler","type":"event"},{"stateMutability":"nonpayable","type":"fallback"},{"inputs":[{"internalType":"address","name":"handler","type":"address"}],"name":"setFallbackHandler","outputs":[],"stateMutability":"nonpayable","type":"function"}],"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"methodIdentifiers":{"setFallbackHandler(address)":"f08a0323"}},"metadata":"{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"handler\",\"type\":\"address\"}],\"name\":\"ChangedFallbackHandler\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"handler\",\"type\":\"address\"}],\"name\":\"setFallbackHandler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"@safe-global/safe-protocol\",\"kind\":\"dev\",\"methods\":{\"setFallbackHandler(address)\":{\"details\":\"1. Only fallback calls without value and with data will be forwarded.      2. Changing the fallback handler can only be done via a Safe transaction.      3. Cannot be set to the Safe itself.      4. IMPORTANT! SECURITY RISK! The fallback handler can be set to any address and all the calls will be forwarded to it,         bypassing all the Safe's access control mechanisms. When setting the fallback handler, make sure to check the address         is a trusted contract and if it supports state changes, it implements the necessary checks.\",\"params\":{\"handler\":\"contract to handle fallback calls.\"}}},\"title\":\"IFallbackManager - A contract interface managing fallback calls made to this contract.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"setFallbackHandler(address)\":{\"notice\":\"Set Fallback Handler to `handler` for the Safe.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"project/contracts/interfaces/IFallbackManager.sol\":\"IFallbackManager\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"project/contracts/interfaces/IFallbackManager.sol\":{\"keccak256\":\"0xfd9e85f08b47630f95a1a578e7c81ff4b9509e019202f1f14ae702dc99e75a90\",\"license\":\"LGPL-3.0-only\",\"urls\":[\"bzz-raw://c305a920293edc1513acbe4421b0b4b24f402b45ba4852abf1aabd244effbb4b\",\"dweb:/ipfs/QmU8V4dMSZ9aKdRnvgqpqjnsh1fmqJRbVTGJsDjam7CxVS\"]}},\"version\":1}"}}},"sources":{"project/contracts/interfaces/IFallbackManager.sol":{"ast":{"absolutePath":"project/contracts/interfaces/IFallbackManager.sol","exportedSymbols":{"IFallbackManager":[17]},"id":18,"license":"LGPL-3.0-only","nodeType":"SourceUnit","nodes":[{"id":1,"literals":["solidity",">=","0.7",".0","<","0.9",".0"],"nodeType":"PragmaDirective","src":"43:31:0"},{"abstract":false,"baseContracts":[],"canonicalName":"IFallbackManager","contractDependencies":[],"contractKind":"interface","documentation":{"id":2,"nodeType":"StructuredDocumentation","src":"78:145:0","text":" @title IFallbackManager - A contract interface managing fallback calls made to this contract.\n @author @safe-global/safe-protocol"},"fullyImplemented":false,"id":17,"linearizedBaseContracts":[17],"name":"IFallbackManager","nameLocation":"235:16:0","nodeType":"ContractDefinition","nodes":[{"anonymous":false,"eventSelector":"5ac6c46c93c8d0e53714ba3b53db3e7c046da994313d7ed0d192028bc7c228b0","id":6,"name":"ChangedFallbackHandler","nameLocation":"265:22:0","nodeType":"EventDefinition","parameters":{"id":5,"nodeType":"ParameterList","parameters":[{"constant":false,"id":4,"indexed":true,"mutability":"mutable","name":"handler","nameLocation":"304:7:0","nodeType":"VariableDeclaration","scope":6,"src":"288:23:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":3,"name":"address","nodeType":"ElementaryTypeName","src":"288:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"287:25:0"},"src":"259:54:0"},{"documentation":{"id":7,"nodeType":"StructuredDocumentation","src":"321:728:0","text":" @notice Set Fallback Handler to `handler` for the Safe.\n @dev 1. Only fallback calls without value and with data will be forwarded.\n      2. Changing the fallback handler can only be done via a Safe transaction.\n      3. Cannot be set to the Safe itself.\n      4. IMPORTANT! SECURITY RISK! The fallback handler can be set to any address and all the calls will be forwarded to it,\n         bypassing all the Safe's access control mechanisms. When setting the fallback handler, make sure to check the address\n         is a trusted contract and if it supports state changes, it implements the necessary checks.\n @param handler contract to handle fallback calls."},"functionSelector":"f08a0323","id":12,"implemented":false,"kind":"function","modifiers":[],"name":"setFallbackHandler","nameLocation":"1064:18:0","nodeType":"FunctionDefinition","parameters":{"id":10,"nodeType":"ParameterList","parameters":[{"constant":false,"id":9,"mutability":"mutable","name":"handler","nameLocation":"1091:7:0","nodeType":"VariableDeclaration","scope":12,"src":"1083:15:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":8,"name":"address","nodeType":"ElementaryTypeName","src":"1083:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"1082:17:0"},"returnParameters":{"id":11,"nodeType":"ParameterList","parameters":[],"src":"1108:0:0"},"scope":17,"src":"1055:54:0","stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"documentation":{"id":13,"nodeType":"StructuredDocumentation","src":"1117:530:0","text":" @notice Forwards all calls to the fallback handler if set.\n         Returns empty data if no handler is set.\n @dev Appends the non-padded caller address to the calldata to be optionally used in the handler\n      The handler can make use of {HandlerContext} to extract the address.\n      This is done because in the next call frame the `msg.sender` will be {FallbackManager}'s address\n      and having the original caller address may enable additional verification scenarios."},"id":16,"implemented":false,"kind":"fallback","modifiers":[],"name":"","nameLocation":"-1:-1:-1","nodeType":"FunctionDefinition","parameters":{"id":14,"nodeType":"ParameterList","parameters":[],"src":"1661:2:0"},"returnParameters":{"id":15,"nodeType":"ParameterList","parameters":[],"src":"1672:0:0"},"scope":17,"src":"1653:20:0","stateMutability":"nonpayable","virtual":false,"visibility":"external"}],"scope":18,"src":"225:1451:0","usedErrors":[],"usedEvents":[6]}],"src":"43:1635:0"},"id":0}}}}