{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-656f636829de3523a8e2a5aaf57341520a1c1f7f",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/handler/CompatibilityFallbackHandler.sol": "project/contracts/handler/CompatibilityFallbackHandler.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/handler/CompatibilityFallbackHandler.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {ISafe} from \"./../interfaces/ISafe.sol\";\r\nimport {ISignatureValidator} from \"./../interfaces/ISignatureValidator.sol\";\r\nimport {Enum} from \"./../libraries/Enum.sol\";\r\nimport {TokenCallbackHandler} from \"./TokenCallbackHandler.sol\";\r\n\r\n/**\r\n * @title Compatibility Fallback Handler\r\n * @notice Provides compatibility between pre 1.3.0 and 1.3.0+ Safe smart account contracts.\r\n * @dev ⚠️⚠️⚠️ This contract is only intended for being used as a fallback handler for a {Safe}.\r\n *      Using it in other ways may cause undefined behavior. ⚠️⚠️⚠️\r\n * @author Richard Meissner - @rmeissner\r\n */\r\ncontract CompatibilityFallbackHandler is\r\n    TokenCallbackHandler,\r\n    ISignatureValidator\r\n{\r\n    /**\r\n     * @dev The precomputed EIP-712 type hash for the Safe message type.\r\n     *      Precomputed value of: `keccak256(\"SafeMessage(bytes message)\")`.\r\n     */\r\n    bytes32 private constant SAFE_MSG_TYPEHASH =\r\n        0x60b3cbf8b4a223d68d641b3b6ddf9a298e7f33710cf3d3a9d1146b5a6150fbca;\r\n\r\n    /**\r\n     * @dev The precomputed EIP-712 type hash for the Safe transaction type.\r\n     *      Precomputed value of: `keccak256(\"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\")`.\r\n     */\r\n    bytes32 private constant SAFE_TX_TYPEHASH =\r\n        0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\r\n\r\n    /**\r\n     * @dev The sentinel module value in the {ModuleManager.modules} linked list.\r\n     *      See {ModuleManager.SENTINEL_MODULES} for more information.\r\n     */\r\n    address internal constant SENTINEL_MODULES = address(0x1);\r\n\r\n    /**\r\n     * @notice Returns the hash of a message to be signed by owners.\r\n     * @dev This function assumes that the caller is a Safe contract.\r\n     * @param message Raw message bytes.\r\n     * @return Message hash.\r\n     */\r\n    function getMessageHash(\r\n        bytes memory message\r\n    ) public view returns (bytes32) {\r\n        return getMessageHashForSafe(ISafe(payable(msg.sender)), message);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the pre-image of the message hash (see {getMessageHashForSafe}).\r\n     * @param safe Safe to which the message is targeted.\r\n     * @param message Message that should be encoded.\r\n     * @return Encoded message.\r\n     */\r\n    function encodeMessageDataForSafe(\r\n        ISafe safe,\r\n        bytes memory message\r\n    ) public view returns (bytes memory) {\r\n        bytes32 safeMessageHash = keccak256(\r\n            abi.encode(SAFE_MSG_TYPEHASH, keccak256(message))\r\n        );\r\n        return\r\n            abi.encodePacked(\r\n                bytes1(0x19),\r\n                bytes1(0x01),\r\n                safe.domainSeparator(),\r\n                safeMessageHash\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the hash of a message that can be signed by owners.\r\n     * @param safe Safe to which the message is targeted.\r\n     * @param message Message that should be hashed.\r\n     * @return Message hash.\r\n     */\r\n    function getMessageHashForSafe(\r\n        ISafe safe,\r\n        bytes memory message\r\n    ) public view returns (bytes32) {\r\n        return keccak256(encodeMessageDataForSafe(safe, message));\r\n    }\r\n\r\n    /**\r\n     * @notice Implementation of the EIP-1271 signature validation method.\r\n     * @dev This implementation verifies signatures for a `ISafe(msg.sender)`.\r\n     * @param _dataHash Hash of the data signed.\r\n     * @param _signature Signature data.\r\n     * @return The EIP-1271 magic value if the signature is valid, reverts otherwise.\r\n     */\r\n    function isValidSignature(\r\n        bytes32 _dataHash,\r\n        bytes calldata _signature\r\n    ) public view override returns (bytes4) {\r\n        // Caller should be a Safe.\r\n        ISafe safe = ISafe(payable(msg.sender));\r\n        bytes memory messageData = encodeMessageDataForSafe(\r\n            safe,\r\n            abi.encode(_dataHash)\r\n        );\r\n        bytes32 messageHash = keccak256(messageData);\r\n        if (_signature.length == 0) {\r\n            require(safe.signedMessages(messageHash) != 0, \"Hash not approved\");\r\n        } else {\r\n            // We explicitly do not allow caller approved signatures for EIP-1271 to prevent unexpected behaviour. This\r\n            // is done by setting the executor address to `0` which can never be an owner of the Safe.\r\n            safe.checkSignatures(address(0), messageHash, _signature);\r\n        }\r\n        return EIP1271_MAGIC_VALUE;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns array of first 10 modules.\r\n     * @return Array of modules.\r\n     */\r\n    function getModules() external view returns (address[] memory) {\r\n        // Caller should be a Safe.\r\n        ISafe safe = ISafe(payable(msg.sender));\r\n        (address[] memory array, ) = safe.getModulesPaginated(\r\n            SENTINEL_MODULES,\r\n            10\r\n        );\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * @notice Performs a `DELEGATECALL` to a `targetContract` in the context of self.\r\n     * @dev Internally reverts execution to avoid side effects (making it effectively static).\r\n     *      Catches the internal revert and returns encoded result as bytes.\r\n     *      Inspired by <https://github.com/gnosis/util-contracts/blob/bb5fe5fb5df6d8400998094fb1b32a178a47c3a1/contracts/StorageAccessible.sol>.\r\n     *      ⚠️⚠️⚠️ This function assumes the caller is a Safe contract is only intended for being used as a fallback handler for a {Safe}.\r\n     *      Using it in other ways may cause undefined behavior. ⚠️⚠️⚠️\r\n     * @param targetContract Address of the contract containing the code to execute.\r\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\r\n     */\r\n    function simulate(\r\n        address targetContract,\r\n        bytes calldata calldataPayload\r\n    ) external returns (bytes memory response) {\r\n        // Suppress compiler warnings about not using parameters, while allowing\r\n        // parameters to keep names for documentation purposes. This does not\r\n        // generate code.\r\n        targetContract;\r\n        calldataPayload;\r\n\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            // Store `simulateAndRevert.selector`.\r\n            // String representation is used to force right padding.\r\n            mstore(ptr, \"\\xb4\\xfa\\xba\\x09\")\r\n\r\n            // Abuse the fact that both this and the internal methods have the\r\n            // same signature, and differ only in symbol name (and therefore,\r\n            // selector) and copy calldata directly. This saves us approximately\r\n            // 250 bytes of code and 300 gas at runtime over the\r\n            // `abi.encodeWithSelector` builtin.\r\n            calldatacopy(add(ptr, 0x04), 0x04, sub(calldatasize(), 0x04))\r\n\r\n            let success := call(\r\n                gas(),\r\n                // `address()` has been changed to `caller()` to use the\r\n                // implementation of the calling Safe.\r\n                caller(),\r\n                0,\r\n                ptr,\r\n                calldatasize(),\r\n                // The `simulateAndRevert` call should always reverts, and\r\n                // instead encodes whether or not it was successful in the\r\n                // return data. The first 32-byte word of the return data\r\n                // contains the `success` value, and the second 32-byte word\r\n                // contains the response bytes length, so write them to memory\r\n                // address 0x00 (Solidity scratch which is OK to use).\r\n                0x00,\r\n                0x40\r\n            )\r\n\r\n            // Double check that the call reverted as expected, and that the\r\n            // `returndata` is long enough to hold the encoded success boolean\r\n            // and response bytes length (64 bytes total). This will always be\r\n            // the case if the caller is a Safe, but check anyway to make sure\r\n            // this function does not make unexpected state changes when\r\n            // called by other contracts.\r\n            if or(success, lt(returndatasize(), 0x40)) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // Allocate and copy the response bytes, making sure to increment\r\n            // the free memory pointer accordingly (in case this method is\r\n            // called as an internal function). The remaining `returndata[0x20:]`\r\n            // contains the ABI encoded response bytes, so we can just copy it\r\n            // as is to memory. Note that `returndatacopy` will revert if we\r\n            // try to copy past the `returndatasize` bounds, so we don't need an\r\n            // additional check here. However, do note that this will consume\r\n            // all remaining gas. This is fine (since we don't aim to support\r\n            // other callers that aren't Safes with the compatibility fallback\r\n            // handler).\r\n            let responseEncodedSize := add(mload(0x20), 0x20)\r\n            response := mload(0x40)\r\n            mstore(0x40, add(response, responseEncodedSize))\r\n            returndatacopy(response, 0x20, responseEncodedSize)\r\n\r\n            if iszero(mload(0x00)) {\r\n                revert(add(response, 0x20), responseEncodedSize)\r\n            }\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the pre-image of the Safe transaction hash (see {Safe.getTransactionHash}).\r\n     * @dev This method is added to the {CompatibilityFallbackHandler} for backwards compatibility with previous versions of Safe.\r\n     *      For a given Safe, the invariant `getTransactionHash(...) == keccak256(encodeTransactionData(...))` holds true.\r\n     * @param to Destination address of the Safe transaction.\r\n     * @param value Native token value of the Safe transaction.\r\n     * @param data Data payload of the Safe transaction.\r\n     * @param operation Operation type of the Safe transaction: 0 for `CALL` and 1 for `DELEGATECALL`.\r\n     * @param safeTxGas Gas that should be used for the Safe transaction.\r\n     * @param baseGas Base gas costs that are independent of the transaction execution (e.g. base transaction fee, signature check, payment of the refund).\r\n     * @param gasPrice Gas price that should be used for the payment calculation.\r\n     * @param gasToken Token address (or 0 for the native token) that is used for the payment.\r\n     * @param refundReceiver Address of receiver of the gas payment (or 0 for `tx.origin`).\r\n     * @param nonce Transaction nonce.\r\n     * @return Transaction hash pre-image bytes.\r\n     */\r\n    function encodeTransactionData(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address refundReceiver,\r\n        uint256 nonce\r\n    ) public view returns (bytes memory) {\r\n        // Caller should be a Safe.\r\n        ISafe safe = ISafe(payable(msg.sender));\r\n        bytes32 domainSeparator = safe.domainSeparator();\r\n        bytes32 safeTxHash = keccak256(\r\n            abi.encode(\r\n                SAFE_TX_TYPEHASH,\r\n                to,\r\n                value,\r\n                keccak256(data),\r\n                operation,\r\n                safeTxGas,\r\n                baseGas,\r\n                gasPrice,\r\n                gasToken,\r\n                refundReceiver,\r\n                nonce\r\n            )\r\n        );\r\n        return\r\n            abi.encodePacked(\r\n                bytes1(0x19),\r\n                bytes1(0x01),\r\n                domainSeparator,\r\n                safeTxHash\r\n            );\r\n    }\r\n}\r\n"
      },
      "project/contracts/handler/HandlerContext.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {ISafe} from \"../interfaces/ISafe.sol\";\r\n\r\n/**\r\n * @title Handler Context - Allows the fallback handler to extract additional context from the calldata\r\n * @dev The fallback manager appends the following context to the calldata:\r\n *      1. Fallback manager caller address (non-padded)\r\n * based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/f8cc8b844a9f92f63dc55aa581f7d643a1bc5ac1/contracts/metatx/ERC2771Context.sol\r\n * @author Richard Meissner - @rmeissner\r\n */\r\nabstract contract HandlerContext {\r\n    /**\r\n     * @dev The storage slot used for storing the currently configured fallback handler address.\r\n     *      Precomputed value of: `keccak256(\"fallback_manager.handler.address\")`.\r\n     */\r\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\r\n\r\n    /**\r\n     * @notice A modifier that reverts if not called by a Safe as a fallback handler.\r\n     * @dev Note that this modifier does a **best effort** attempt at not allowing calls that are\r\n     *      not as a fallback call, but it still can be tricked. It is suitable for use cases such\r\n     *      making a best effort attempt to disallow ERC-721 and ERC-1155 token transfers to the\r\n     *      fallback handler contract.\r\n     */\r\n    modifier onlyFallback() {\r\n        _requireFallback();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Implementation of the {onlySafeFallback} modifier check that the current call is a Safe\r\n     *      fallback call, and the contract is not called directly. Note that this is only a **best\r\n     *      effort** check and may generate false positives under certain conditions.\r\n     */\r\n    function _requireFallback() internal view {\r\n        bytes memory storageData = ISafe(payable(msg.sender)).getStorageAt(uint256(FALLBACK_HANDLER_STORAGE_SLOT), 1);\r\n        address fallbackHandler = abi.decode(storageData, (address));\r\n        require(fallbackHandler == address(this), \"not a fallback call\");\r\n    }\r\n\r\n    /**\r\n     * @notice Allows fetching the original caller address.\r\n     * @dev This is only reliable in combination with a FallbackManager that supports this (e.g. Safe contract >=1.3.0).\r\n     *      When using this functionality make sure that the linked _manager (aka msg.sender) supports this.\r\n     *      This function does not rely on a trusted forwarder. Use the returned value only to\r\n     *      check information against the calling manager.\r\n     * @return sender Original caller address.\r\n     */\r\n    function _msgSender() internal pure returns (address sender) {\r\n        require(msg.data.length >= 20, \"Invalid calldata length\");\r\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the FallbackManager address\r\n     * @return Fallback manager address\r\n     */\r\n    function _manager() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n"
      },
      "project/contracts/handler/TokenCallbackHandler.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {ERC1155TokenReceiver} from \"../interfaces/ERC1155TokenReceiver.sol\";\r\nimport {ERC721TokenReceiver} from \"../interfaces/ERC721TokenReceiver.sol\";\r\nimport {ERC777TokensRecipient} from \"../interfaces/ERC777TokensRecipient.sol\";\r\nimport {IERC165} from \"../interfaces/IERC165.sol\";\r\nimport {HandlerContext} from \"./HandlerContext.sol\";\r\n\r\n/**\r\n * @title Token Callback Handler\r\n * @notice Handles supported tokens' callbacks, allowing Safes to receive these tokens.\r\n * @dev ⚠️ WARNING: This contract implements various token callback functions, which makes it\r\n *      possible for itself to receive these tokens despite not being designed to do so,\r\n *      PERMANENTLY LOCKING THOSE TOKENS. Do not send tokens to this contract.\r\n * @author Richard Meissner - @rmeissner\r\n */\r\ncontract TokenCallbackHandler is HandlerContext, ERC1155TokenReceiver, ERC777TokensRecipient, ERC721TokenReceiver, IERC165 {\r\n    /**\r\n     * @notice Handles ERC-1155 Token callback.\r\n     * @return Standardized onERC1155Received return value.\r\n     */\r\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external view override onlyFallback returns (bytes4) {\r\n        return 0xf23a6e61;\r\n    }\r\n\r\n    /**\r\n     * @notice Handles ERC-1155 Token batch callback.\r\n     * @return Standardized onERC1155BatchReceived return value.\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] calldata,\r\n        uint256[] calldata,\r\n        bytes calldata\r\n    ) external view override onlyFallback returns (bytes4) {\r\n        return 0xbc197c81;\r\n    }\r\n\r\n    /**\r\n     * @notice Handles ERC-721 Token callback.\r\n     * @return Standardized onERC721Received return value.\r\n     */\r\n    function onERC721Received(address, address, uint256, bytes calldata) external view override onlyFallback returns (bytes4) {\r\n        return 0x150b7a02;\r\n    }\r\n\r\n    /**\r\n     * @notice Handles ERC-777 Token callback.\r\n     * @dev Account that wishes to receive the tokens also needs to register the implementer (this contract) via the ERC-1820 interface registry.\r\n     *      From the standard: \"This is done by calling the setInterfaceImplementer function on the ERC-1820 registry with the holder address as\r\n     *      the address, the keccak256 hash of ERC777TokensSender (0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895) as the\r\n     *      interface hash, and the address of the contract implementing the ERC777TokensSender as the implementer.\"\r\n     */\r\n    function tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external pure override {\r\n        // We implement this for completeness, doesn't really have any value\r\n    }\r\n\r\n    /**\r\n     * @notice Implements ERC-165 interface support for ERC1155TokenReceiver, ERC721TokenReceiver and IERC165.\r\n     * @param interfaceId Id of the interface.\r\n     * @return if the interface is supported.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\r\n        return\r\n            interfaceId == type(ERC1155TokenReceiver).interfaceId ||\r\n            interfaceId == type(ERC721TokenReceiver).interfaceId ||\r\n            interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n"
      },
      "project/contracts/interfaces/ERC1155TokenReceiver.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n// Note: The ERC-165 identifier for this interface is 0x4e2312e0.\r\ninterface ERC1155TokenReceiver {\r\n    /**\r\n     * @notice Handle the receipt of a single ERC1155 token type.\r\n     * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *      This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\r\n     *      This function MUST revert if it rejects the transfer.\r\n     *      Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\r\n     * @param _operator  The address which initiated the transfer (i.e. msg.sender).\r\n     * @param _from      The address which previously owned the token.\r\n     * @param _id        The ID of the token being transferred.\r\n     * @param _value     The amount of tokens being transferred.\r\n     * @param _data      Additional data with no specified format.\r\n     * @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`.\r\n     */\r\n    function onERC1155Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _id,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @notice Handle the receipt of multiple ERC1155 token types.\r\n     * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\r\n     *      This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\r\n     *      This function MUST revert if it rejects the transfer(s).\r\n     *      Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\r\n     * @param _operator  The address which initiated the batch transfer (i.e. msg.sender).\r\n     * @param _from      The address which previously owned the token.\r\n     * @param _ids       An array containing ids of each token being transferred (order and length must match _values array).\r\n     * @param _values    An array containing amounts of each token being transferred (order and length must match _ids array).\r\n     * @param _data      Additional data with no specified format.\r\n     * @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`.\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address _operator,\r\n        address _from,\r\n        uint256[] calldata _ids,\r\n        uint256[] calldata _values,\r\n        bytes calldata _data\r\n    ) external returns (bytes4);\r\n}\r\n"
      },
      "project/contracts/interfaces/ERC721TokenReceiver.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface ERC721TokenReceiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     *  after a `transfer`. This function MAY throw to revert and reject the\r\n     *  transfer. Return of other than the magic value MUST result in the\r\n     *  transaction being reverted.\r\n     *  Note: the contract address is always the message sender.\r\n     * @param _operator The address which called `safeTransferFrom` function.\r\n     * @param _from The address which previously owned the token.\r\n     * @param _tokenId The NFT identifier which is being transferred.\r\n     * @param _data Additional data with no specified format.\r\n     * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n     *  unless throwing\r\n     */\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);\r\n}\r\n"
      },
      "project/contracts/interfaces/ERC777TokensRecipient.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title ERC777TokensRecipient\r\n * @dev Interface for contracts that will be called with the ERC777 token's `tokensReceived` method.\r\n * The contract receiving the tokens must implement this interface in order to receive the tokens.\r\n */\r\ninterface ERC777TokensRecipient {\r\n    /**\r\n     * @dev Called by the ERC777 token contract after a successful transfer or a minting operation.\r\n     * @param operator The address of the operator performing the transfer or minting operation.\r\n     * @param from The address of the sender.\r\n     * @param to The address of the recipient.\r\n     * @param amount The amount of tokens that were transferred or minted.\r\n     * @param data Additional data that was passed during the transfer or minting operation.\r\n     * @param operatorData Additional data that was passed by the operator during the transfer or minting operation.\r\n     */\r\n    function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n"
      },
      "project/contracts/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/// @notice More details at https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by `interfaceId`.\r\n     * See the corresponding EIP section\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n"
      },
      "project/contracts/interfaces/IFallbackManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title IFallbackManager - A contract interface managing fallback calls made to this contract.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IFallbackManager {\r\n    event ChangedFallbackHandler(address indexed handler);\r\n\r\n    /**\r\n     * @notice Set Fallback Handler to `handler` for the Safe.\r\n     * @dev 1. Only fallback calls without value and with data will be forwarded.\r\n     *      2. Changing the fallback handler can only be done via a Safe transaction.\r\n     *      3. Cannot be set to the Safe itself.\r\n     *      4. IMPORTANT! SECURITY RISK! The fallback handler can be set to any address and all the calls will be forwarded to it,\r\n     *         bypassing all the Safe's access control mechanisms. When setting the fallback handler, make sure to check the address\r\n     *         is a trusted contract and if it supports state changes, it implements the necessary checks.\r\n     * @param handler contract to handle fallback calls.\r\n     */\r\n    function setFallbackHandler(address handler) external;\r\n\r\n    /**\r\n     * @notice Forwards all calls to the fallback handler if set.\r\n     *         Returns empty data if no handler is set.\r\n     * @dev Appends the non-padded caller address to the calldata to be optionally used in the handler\r\n     *      The handler can make use of {HandlerContext} to extract the address.\r\n     *      This is done because in the next call frame the `msg.sender` will be {FallbackManager}'s address\r\n     *      and having the original caller address may enable additional verification scenarios.\r\n     */\r\n    fallback() external;\r\n}\r\n"
      },
      "project/contracts/interfaces/IGuardManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\n/* solhint-disable one-contract-per-file */\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title IGuardManager - A contract interface managing transaction guards which perform pre and post-checks on Safe transactions.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IGuardManager {\r\n    event ChangedGuard(address indexed guard);\r\n\r\n    /**\r\n     * @dev Set a guard that checks transactions before execution\r\n     *      This can only be done via a Safe transaction.\r\n     *      ⚠️ IMPORTANT: Since a guard has full power to block Safe transaction execution,\r\n     *        a broken guard can cause a denial of service for the Safe. Make sure to carefully\r\n     *        audit the guard code and design recovery mechanisms.\r\n     * @notice Set Transaction Guard `guard` for the Safe. Make sure you trust the guard.\r\n     * @param guard The address of the guard to be used or the 0 address to disable the guard\r\n     */\r\n    function setGuard(address guard) external;\r\n}\r\n"
      },
      "project/contracts/interfaces/IModuleManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\nimport {Enum} from \"../libraries/Enum.sol\";\r\n\r\n/**\r\n * @title IModuleManager - An interface of contract managing Safe modules\r\n * @notice Modules are extensions with unlimited access to a Safe that can be added to a Safe by its owners.\r\n           ⚠️ WARNING: Modules are a security risk since they can execute arbitrary transactions, \r\n           so only trusted and audited modules should be added to a Safe. A malicious module can\r\n           completely takeover a Safe.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IModuleManager {\r\n    event EnabledModule(address indexed module);\r\n    event DisabledModule(address indexed module);\r\n    event ExecutionFromModuleSuccess(address indexed module);\r\n    event ExecutionFromModuleFailure(address indexed module);\r\n    event ChangedModuleGuard(address indexed moduleGuard);\r\n\r\n    /**\r\n     * @notice Enables the module `module` for the Safe.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param module Module to be whitelisted.\r\n     */\r\n    function enableModule(address module) external;\r\n\r\n    /**\r\n     * @notice Disables the module `module` for the Safe.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param prevModule Previous module in the modules linked list.\r\n     * @param module Module to be removed.\r\n     */\r\n    function disableModule(address prevModule, address module) external;\r\n\r\n    /**\r\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token)\r\n     * @param to Destination address of module transaction.\r\n     * @param value Ether value of module transaction.\r\n     * @param data Data payload of module transaction.\r\n     * @param operation Operation type of module transaction.\r\n     * @return success Boolean flag indicating if the call succeeded.\r\n     */\r\n    function execTransactionFromModule(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation\r\n    ) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token) and return data\r\n     * @param to Destination address of module transaction.\r\n     * @param value Ether value of module transaction.\r\n     * @param data Data payload of module transaction.\r\n     * @param operation Operation type of module transaction.\r\n     * @return success Boolean flag indicating if the call succeeded.\r\n     * @return returnData Data returned by the call.\r\n     */\r\n    function execTransactionFromModuleReturnData(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation\r\n    ) external returns (bool success, bytes memory returnData);\r\n\r\n    /**\r\n     * @notice Returns if a module is enabled\r\n     * @return True if the module is enabled\r\n     */\r\n    function isModuleEnabled(address module) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns an array of modules.\r\n     *         If all entries fit into a single page, the next pointer will be 0x1.\r\n     *         If another page is present, next will be the last element of the returned array.\r\n     * @param start Start of the page. Has to be a module or start pointer (0x1 address)\r\n     * @param pageSize Maximum number of modules that should be returned. Has to be > 0\r\n     * @return array Array of modules.\r\n     * @return next Start of the next page.\r\n     */\r\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next);\r\n\r\n    /**\r\n     * @dev Set a module guard that checks transactions initiated by the module before execution\r\n     *      This can only be done via a Safe transaction.\r\n     *      ⚠️ IMPORTANT: Since a module guard has full power to block Safe transaction execution initiated via a module,\r\n     *        a broken module guard can cause a denial of service for the Safe modules. Make sure to carefully\r\n     *        audit the module guard code and design recovery mechanisms.\r\n     * @notice Set Module Guard `moduleGuard` for the Safe. Make sure you trust the module guard.\r\n     * @param moduleGuard The address of the module guard to be used or the zero address to disable the module guard.\r\n     */\r\n    function setModuleGuard(address moduleGuard) external;\r\n}\r\n"
      },
      "project/contracts/interfaces/INativeCurrencyPaymentFallback.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title Native Currency Payment Fallback Interface\r\n * @notice An interface to a contract that can receive native currency payments.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface INativeCurrencyPaymentFallback {\r\n    event SafeReceived(address indexed sender, uint256 value);\r\n\r\n    /**\r\n     * @notice Receive function accepts native currency transactions.\r\n     * @dev Emits an event with sender and received value.\r\n     */\r\n    receive() external payable;\r\n}\r\n"
      },
      "project/contracts/interfaces/IOwnerManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title IOwnerManager - Interface for contract which manages Safe owners and a threshold to authorize transactions.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IOwnerManager {\r\n    event AddedOwner(address indexed owner);\r\n    event RemovedOwner(address indexed owner);\r\n    event ChangedThreshold(uint256 threshold);\r\n\r\n    /**\r\n     * @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param owner New owner address.\r\n     * @param _threshold New threshold.\r\n     */\r\n    function addOwnerWithThreshold(address owner, uint256 _threshold) external;\r\n\r\n    /**\r\n     * @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param prevOwner Owner that pointed to the owner to be removed in the linked list\r\n     * @param owner Owner address to be removed.\r\n     * @param _threshold New threshold.\r\n     */\r\n    function removeOwner(address prevOwner, address owner, uint256 _threshold) external;\r\n\r\n    /**\r\n     * @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param prevOwner Owner that pointed to the owner to be replaced in the linked list\r\n     * @param oldOwner Owner address to be replaced.\r\n     * @param newOwner New owner address.\r\n     */\r\n    function swapOwner(address prevOwner, address oldOwner, address newOwner) external;\r\n\r\n    /**\r\n     * @notice Changes the threshold of the Safe to `_threshold`.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param _threshold New threshold.\r\n     */\r\n    function changeThreshold(uint256 _threshold) external;\r\n\r\n    /**\r\n     * @notice Returns the number of required confirmations for a Safe transaction aka the threshold.\r\n     * @return Threshold number.\r\n     */\r\n    function getThreshold() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns if `owner` is an owner of the Safe.\r\n     * @return Boolean if `owner` is an owner of the Safe.\r\n     */\r\n    function isOwner(address owner) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns a list of Safe owners.\r\n     * @return Array of Safe owners.\r\n     */\r\n    function getOwners() external view returns (address[] memory);\r\n}\r\n"
      },
      "project/contracts/interfaces/ISafe.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {Enum} from \"./../libraries/Enum.sol\";\r\nimport {IFallbackManager} from \"./IFallbackManager.sol\";\r\nimport {IGuardManager} from \"./IGuardManager.sol\";\r\nimport {IModuleManager} from \"./IModuleManager.sol\";\r\nimport {INativeCurrencyPaymentFallback} from \"./INativeCurrencyPaymentFallback.sol\";\r\nimport {IOwnerManager} from \"./IOwnerManager.sol\";\r\nimport {IStorageAccessible} from \"./IStorageAccessible.sol\";\r\n\r\n/**\r\n * @title ISafe - A multisignature wallet interface with support for confirmations using signed messages based on EIP-712.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface ISafe is INativeCurrencyPaymentFallback, IModuleManager, IGuardManager, IOwnerManager, IFallbackManager, IStorageAccessible {\r\n    event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);\r\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\r\n    event SignMsg(bytes32 indexed msgHash);\r\n    event ExecutionFailure(bytes32 indexed txHash, uint256 payment);\r\n    event ExecutionSuccess(bytes32 indexed txHash, uint256 payment);\r\n\r\n    /**\r\n     * @notice Sets an initial storage of the Safe contract.\r\n     * @dev This method can only be called once.\r\n     *      If a proxy was created without setting up, anyone can call setup and claim the proxy.\r\n     *      This method emits a {SafeSetup} event with the setup parameters instead of reading from storage,\r\n     *      which may be inaccurate if the delegate call to `to` modifies the owners, threshold or fallback handler.\r\n     * @param _owners List of Safe owners.\r\n     * @param _threshold Number of required confirmations for a Safe transaction.\r\n     * @param to Contract address for optional delegate call.\r\n     * @param data Data payload for optional delegate call.\r\n     * @param fallbackHandler Handler for fallback calls to this contract\r\n     * @param paymentToken Token that should be used for the payment (0 is ETH)\r\n     * @param payment Value that should be paid\r\n     * @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)\r\n     */\r\n    function setup(\r\n        address[] calldata _owners,\r\n        uint256 _threshold,\r\n        address to,\r\n        bytes calldata data,\r\n        address fallbackHandler,\r\n        address paymentToken,\r\n        uint256 payment,\r\n        address payable paymentReceiver\r\n    ) external;\r\n\r\n    /** @notice Executes a `operation` {0: Call, 1: DelegateCall} transaction to `to` with `value` (Native Currency)\r\n     *          and pays `gasPrice` * `gasLimit` in `gasToken` token to `refundReceiver`.\r\n     * @dev The fees are always transferred, even if the user transaction fails.\r\n     *      This method doesn't perform any sanity check of the transaction, such as:\r\n     *      - if the contract at `to` address has code or not\r\n     *      - if the `gasToken` is a contract or not\r\n     *      It is the responsibility of the caller to perform such checks.\r\n     * @param to Destination address of Safe transaction.\r\n     * @param value Ether value of Safe transaction.\r\n     * @param data Data payload of Safe transaction.\r\n     * @param operation Operation type of Safe transaction.\r\n     * @param safeTxGas Gas that should be used for the Safe transaction.\r\n     * @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\r\n     * @param gasPrice Gas price that should be used for the payment calculation.\r\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n     * @param signatures Signature data that should be verified.\r\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\r\n     * @return success Boolean indicating transaction's success.\r\n     */\r\n    function execTransaction(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address payable refundReceiver,\r\n        bytes memory signatures\r\n    ) external payable returns (bool success);\r\n\r\n    /**\r\n     * @notice Checks whether the signature provided is valid for the provided data and hash and executor. Reverts otherwise.\r\n     * @param executor Address that executes the transaction.\r\n     *        ⚠️⚠️⚠️ Make sure that the executor address is a legitimate executor.\r\n     *        Incorrectly passed the executor might reduce the threshold by 1 signature. ⚠️⚠️⚠️\r\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\r\n     * @param signatures Signature data that should be verified.\r\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\r\n     */\r\n    function checkSignatures(address executor, bytes32 dataHash, bytes memory signatures) external view;\r\n\r\n    /**\r\n     * @notice Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.\r\n     * @dev Since the EIP-1271 does an external call, be mindful of reentrancy attacks.\r\n     * @param executor Address that executes the transaction.\r\n     *        ⚠️⚠️⚠️ Make sure that the executor address is a legitimate executor.\r\n     *        Incorrectly passed the executor might reduce the threshold by 1 signature. ⚠️⚠️⚠️\r\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\r\n     * @param signatures Signature data that should be verified.\r\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\r\n     * @param requiredSignatures Amount of required valid signatures.\r\n     */\r\n    function checkNSignatures(address executor, bytes32 dataHash, bytes memory signatures, uint256 requiredSignatures) external view;\r\n\r\n    /**\r\n     * @notice Marks hash `hashToApprove` as approved.\r\n     * @dev This can be used with a pre-approved hash transaction signature.\r\n     *      IMPORTANT: The approved hash stays approved forever. There's no revocation mechanism, so it behaves similarly to ECDSA signatures\r\n     * @param hashToApprove The hash to mark as approved for signatures that are verified by this contract.\r\n     */\r\n    function approveHash(bytes32 hashToApprove) external;\r\n\r\n    /**\r\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\r\n     * @return bytes32 The domain separator hash.\r\n     */\r\n    function domainSeparator() external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Returns transaction hash to be signed by owners.\r\n     * @param to Destination address.\r\n     * @param value Ether value.\r\n     * @param data Data payload.\r\n     * @param operation Operation type.\r\n     * @param safeTxGas Gas that should be used for the safe transaction.\r\n     * @param baseGas Gas costs for data used to trigger the safe transaction.\r\n     * @param gasPrice Maximum gas price that should be used for this transaction.\r\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n     * @param _nonce Transaction nonce.\r\n     * @return Transaction hash.\r\n     */\r\n    function getTransactionHash(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address refundReceiver,\r\n        uint256 _nonce\r\n    ) external view returns (bytes32);\r\n\r\n    /**\r\n     * External getter function for state variables.\r\n     */\r\n\r\n    /**\r\n     * @notice Returns the version of the Safe contract.\r\n     * @return Version string.\r\n     */\r\n    // solhint-disable-next-line\r\n    function VERSION() external view returns (string memory);\r\n\r\n    /**\r\n     * @notice Returns the nonce of the Safe contract.\r\n     * @return Nonce.\r\n     */\r\n    function nonce() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns a uint if the messageHash is signed by the owner.\r\n     * @param messageHash Hash of message that should be checked.\r\n     * @return Number denoting if an owner signed the hash.\r\n     */\r\n    function signedMessages(bytes32 messageHash) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns a uint if the messageHash is approved by the owner.\r\n     * @param owner Owner address that should be checked.\r\n     * @param messageHash Hash of message that should be checked.\r\n     * @return Number denoting if an owner approved the hash.\r\n     */\r\n    function approvedHashes(address owner, bytes32 messageHash) external view returns (uint256);\r\n}\r\n"
      },
      "project/contracts/interfaces/ISignatureValidator.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\n/* solhint-disable one-contract-per-file */\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nabstract contract ISignatureValidatorConstants {\r\n    // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\r\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\r\n}\r\n\r\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\r\n    /**\r\n     * @notice EIP1271 method to validate a signature.\r\n     * @param _hash Hash of the data signed on the behalf of address(this).\r\n     * @param _signature Signature byte array associated with _data.\r\n     *\r\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\r\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\r\n     * MUST allow external calls\r\n     */\r\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external view virtual returns (bytes4);\r\n}\r\n"
      },
      "project/contracts/interfaces/IStorageAccessible.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title Storage Accessible Interface\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IStorageAccessible {\r\n    /**\r\n     * @notice Reads `length` bytes of storage in the current contract\r\n     * @param offset The offset in the current contract's storage in words to start reading from.\r\n     * @param length The number of words (32 bytes) of data to read.\r\n     * @return The bytes that were read.\r\n     */\r\n    function getStorageAt(uint256 offset, uint256 length) external view returns (bytes memory);\r\n\r\n    /**\r\n     * @notice Performs a `DELEGATECALL` to a `targetContract` in the context of self.\r\n     * @dev Internally reverts execution to avoid side effects (making it effectively static).\r\n     *      This method reverts with data equal to `abi.encodePacked(uint256(success), uint256(response.length), bytes(response))`.\r\n     *      Specifically, the return data after a call to this method will be:\r\n     *      `success:uint256 || response.length:uint256 || response:bytes`.\r\n     * @param targetContract Address of the contract containing the code to execute.\r\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\r\n     */\r\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external;\r\n}\r\n"
      },
      "project/contracts/libraries/Enum.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title Enum - Collection of enums used in Safe Smart Account contracts.\r\n * @author @safe-global/safe-protocol\r\n */\r\nlibrary Enum {\r\n    enum Operation {\r\n        Call,\r\n        DelegateCall\r\n    }\r\n}\r\n"
      }
    }
  }
}