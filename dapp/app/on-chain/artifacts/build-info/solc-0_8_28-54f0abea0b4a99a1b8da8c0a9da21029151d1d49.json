{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-54f0abea0b4a99a1b8da8c0a9da21029151d1d49",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/proxies/SafeProxy.sol": "project/contracts/proxies/SafeProxy.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/proxies/SafeProxy.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\n/* solhint-disable one-contract-per-file */\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title IProxy - Helper interface to access the singleton address of the Proxy on-chain.\r\n * @author Richard Meissner - @rmeissner\r\n */\r\ninterface IProxy {\r\n    function masterCopy() external view returns (address);\r\n}\r\n\r\n/**\r\n * @title SafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n * @author Stefan George - <stefan@gnosis.io>\r\n * @author Richard Meissner - <richard@gnosis.io>\r\n */\r\ncontract SafeProxy {\r\n    // Singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\r\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\r\n    address internal singleton;\r\n\r\n    /**\r\n     * @notice Constructor function sets address of singleton contract.\r\n     * @param _singleton Singleton address.\r\n     */\r\n    constructor(address _singleton) {\r\n        require(_singleton != address(0), \"Invalid singleton address provided\");\r\n        singleton = _singleton;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    fallback() external payable {\r\n        // Note that this assembly block is **intentionally** not marked as memory-safe. First of all, it isn't memory\r\n        // safe to begin with, and turning this into memory-safe assembly would just make it less gas efficient.\r\n        // Additionally, we noticed that converting this to memory-safe assembly had no affect on optimizations of other\r\n        // contracts (as it always gets compiled alone in its own compilation unit anyway). Because the assembly block\r\n        // always halts and never returns control back to Solidity, disrespecting Solidity's memory safety invariants\r\n        // is not an issue.\r\n        /* solhint-disable no-inline-assembly */\r\n        assembly {\r\n            let _singleton := sload(0)\r\n            // 0xa619486e == uint32(bytes4(keccak256(\"masterCopy()\"))). Only the 4 first bytes of calldata are\r\n            // considered to make it 100% Solidity ABI conformant.\r\n            if eq(shr(224, calldataload(0)), 0xa619486e) {\r\n                // We mask the singleton address when handling the `masterCopy()` call to ensure that it is correctly\r\n                // ABI-encoded. We do this by shifting the address left by 96 bits (or 12 bytes) and then storing it in\r\n                // memory with a 12 byte offset from where the return data starts. Note that we **intentionally** only\r\n                // do this for the `masterCopy()` call, since the EVM `DELEGATECALL` opcode ignores the most-significant\r\n                // 12 bytes from the address, so we do not need to make sure the top bytes are cleared when proxying\r\n                // calls to the `singleton`. This saves us a tiny amount of gas per proxied call. Additionally, we write\r\n                // to the \"zero-memory\" slot instead of the scratch space, which guarantees that 12 bytes of memory\r\n                // preceding the singleton address are zero (which would not be guaranteed for the scratch space) [1].\r\n                // This ensures that the data we return has the leading 12 bytes set to zero and conforms to the\r\n                // Solidity ABI [2].\r\n                //\r\n                // [1]: https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html\r\n                // [2]: https://docs.soliditylang.org/en/v0.7.6/abi-spec.html#formal-specification-of-the-encoding\r\n                mstore(0x6c, shl(96, _singleton))\r\n                return(0x60, 0x20)\r\n            }\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(\r\n                gas(),\r\n                _singleton,\r\n                0,\r\n                calldatasize(),\r\n                0,\r\n                0\r\n            )\r\n            returndatacopy(0, 0, returndatasize())\r\n            if iszero(success) {\r\n                revert(0, returndatasize())\r\n            }\r\n            return(0, returndatasize())\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n    }\r\n}\r\n"
      }
    }
  }
}