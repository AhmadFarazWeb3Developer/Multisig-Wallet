{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-2c01255d9a0e6917738eb3f5ce7ea724cac2f583",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/handler/ExtensibleFallbackHandler.sol": "project/contracts/handler/ExtensibleFallbackHandler.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/handler/extensible/ERC165Handler.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {IERC165} from \"../../interfaces/IERC165.sol\";\r\nimport {ISafe, MarshalLib, ExtensibleBase} from \"./ExtensibleBase.sol\";\r\n\r\ninterface IERC165Handler {\r\n    function safeInterfaces(ISafe safe, bytes4 interfaceId) external view returns (bool);\r\n\r\n    function setSupportedInterface(bytes4 interfaceId, bool supported) external;\r\n\r\n    function addSupportedInterfaceBatch(bytes4 interfaceId, bytes32[] calldata handlerWithSelectors) external;\r\n\r\n    function removeSupportedInterfaceBatch(bytes4 interfaceId, bytes4[] calldata selectors) external;\r\n}\r\n\r\nabstract contract ERC165Handler is ExtensibleBase, IERC165Handler {\r\n    // --- events ---\r\n\r\n    event AddedInterface(ISafe indexed safe, bytes4 interfaceId);\r\n    event RemovedInterface(ISafe indexed safe, bytes4 interfaceId);\r\n\r\n    // --- storage ---\r\n\r\n    mapping(ISafe => mapping(bytes4 => bool)) public override safeInterfaces;\r\n\r\n    // --- setters ---\r\n\r\n    /**\r\n     * Setter to indicate if an interface is supported (and thus reported by ERC165 supportsInterface)\r\n     * @param interfaceId The interface id whose support is to be set\r\n     * @param supported True if the interface is supported, false otherwise\r\n     */\r\n    function setSupportedInterface(bytes4 interfaceId, bool supported) public override onlySelf {\r\n        ISafe safe = ISafe(payable(_manager()));\r\n        // invalid interface id per ERC165 spec\r\n        require(interfaceId != 0xffffffff, \"invalid interface id\");\r\n        mapping(bytes4 => bool) storage safeInterface = safeInterfaces[safe];\r\n        bool current = safeInterface[interfaceId];\r\n        if (supported != current) {\r\n            safeInterface[interfaceId] = supported;\r\n            if (supported) {\r\n                emit AddedInterface(safe, interfaceId);\r\n            } else {\r\n                emit RemovedInterface(safe, interfaceId);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Batch add selectors for an interface.\r\n     * @param _interfaceId The interface id to set\r\n     * @param handlerWithSelectors The handlers encoded with the 4-byte selectors of the methods\r\n     */\r\n    function addSupportedInterfaceBatch(bytes4 _interfaceId, bytes32[] calldata handlerWithSelectors) external override onlySelf {\r\n        ISafe safe = ISafe(payable(_msgSender()));\r\n        bytes4 interfaceId = bytes4(0);\r\n        uint256 len = handlerWithSelectors.length;\r\n        for (uint256 i = 0; i < len; ++i) {\r\n            (bool isStatic, bytes4 selector, address handlerAddress) = MarshalLib.decodeWithSelector(handlerWithSelectors[i]);\r\n            _setSafeMethod(safe, selector, MarshalLib.encode(isStatic, handlerAddress));\r\n            interfaceId ^= selector;\r\n        }\r\n\r\n        require(interfaceId == _interfaceId, \"interface id mismatch\");\r\n        setSupportedInterface(_interfaceId, true);\r\n    }\r\n\r\n    /**\r\n     * Batch remove selectors for an interface.\r\n     * @param _interfaceId the interface id to remove\r\n     * @param selectors The selectors of the methods to remove\r\n     */\r\n    function removeSupportedInterfaceBatch(bytes4 _interfaceId, bytes4[] calldata selectors) external override onlySelf {\r\n        ISafe safe = ISafe(payable(_msgSender()));\r\n        bytes4 interfaceId = bytes4(0);\r\n        uint256 len = selectors.length;\r\n        for (uint256 i = 0; i < len; ++i) {\r\n            _setSafeMethod(safe, selectors[i], bytes32(0));\r\n            interfaceId ^= selectors[i];\r\n        }\r\n\r\n        require(interfaceId == _interfaceId, \"interface id mismatch\");\r\n        setSupportedInterface(_interfaceId, false);\r\n    }\r\n\r\n    /**\r\n     * @notice Implements ERC165 interface detection for the supported interfaces\r\n     * @dev Inheriting contracts should override `_supportsInterface` to add support for additional interfaces\r\n     * @param interfaceId The ERC165 interface id to check\r\n     * @return True if the interface is supported\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return\r\n            interfaceId == type(IERC165).interfaceId ||\r\n            interfaceId == type(IERC165Handler).interfaceId ||\r\n            _supportsInterface(interfaceId) ||\r\n            safeInterfaces[ISafe(payable(_manager()))][interfaceId];\r\n    }\r\n\r\n    // --- internal ---\r\n\r\n    /**\r\n     * A stub function to be overridden by inheriting contracts to add support for additional interfaces\r\n     * @param interfaceId The interface id to check support for\r\n     * @return True if the interface is supported\r\n     */\r\n    function _supportsInterface(bytes4 interfaceId) internal view virtual returns (bool);\r\n}\r\n"
      },
      "project/contracts/handler/extensible/ExtensibleBase.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {ISafe} from \"../../interfaces/ISafe.sol\";\r\nimport {HandlerContext} from \"../HandlerContext.sol\";\r\nimport {MarshalLib} from \"./MarshalLib.sol\";\r\n\r\ninterface IFallbackMethod {\r\n    function handle(ISafe safe, address sender, uint256 value, bytes calldata data) external returns (bytes memory result);\r\n}\r\n\r\ninterface IStaticFallbackMethod {\r\n    function handle(ISafe safe, address sender, uint256 value, bytes calldata data) external view returns (bytes memory result);\r\n}\r\n\r\n/**\r\n * @title Base contract for Extensible Fallback Handlers\r\n * @dev This contract provides the base for storage and modifiers for extensible fallback handlers\r\n * @author mfw78 <mfw78@rndlabs.xyz>\r\n */\r\nabstract contract ExtensibleBase is HandlerContext {\r\n    // --- events ---\r\n    event ChangedSafeMethod(ISafe indexed safe, bytes4 selector, bytes32 oldMethod, bytes32 newMethod);\r\n\r\n    // --- storage ---\r\n\r\n    // A mapping of Safe => selector => method\r\n    // The method is a bytes32 that is encoded as follows:\r\n    // - The first byte is 0x00 if the method is static and 0x01 if the method is not static\r\n    // - The last 20 bytes are the address of the handler contract\r\n    // The method is encoded / decoded using the MarshalLib\r\n    mapping(ISafe => mapping(bytes4 => bytes32)) public safeMethods;\r\n\r\n    // --- modifiers ---\r\n    modifier onlySelf() {\r\n        // Use the `HandlerContext._msgSender()` to get the caller of the fallback function\r\n        // Use the `HandlerContext._manager()` to get the manager, which should be the Safe\r\n        // Require that the caller is the Safe itself\r\n        require(_msgSender() == _manager(), \"only safe can call this method\");\r\n        _;\r\n    }\r\n\r\n    // --- internal ---\r\n\r\n    function _setSafeMethod(ISafe safe, bytes4 selector, bytes32 newMethod) internal {\r\n        mapping(bytes4 => bytes32) storage safeMethod = safeMethods[safe];\r\n        bytes32 oldMethod = safeMethod[selector];\r\n\r\n        (, address newHandler) = MarshalLib.decode(newMethod);\r\n        if (address(newHandler) == address(0)) {\r\n            // Note that we treat methods with handlers set to the 0 address the same. That\r\n            // is, the `isStatic` flag of the method is ignored. This is because having a\r\n            // handler address of 0 indicates that the method is disabled (regardless of\r\n            // the other flags).\r\n            newMethod = bytes32(0);\r\n        }\r\n\r\n        safeMethod[selector] = newMethod;\r\n        emit ChangedSafeMethod(safe, selector, oldMethod, newMethod);\r\n    }\r\n\r\n    /**\r\n     * Dry code to get the Safe and the original `msg.sender` from the FallbackManager\r\n     * @return safe The safe whose FallbackManager is making this call\r\n     * @return sender The original `msg.sender` (as received by the FallbackManager)\r\n     */\r\n    function _getContext() internal view returns (ISafe safe, address sender) {\r\n        safe = ISafe(payable(_manager()));\r\n        sender = _msgSender();\r\n    }\r\n\r\n    /**\r\n     * Get the context and the method handler applicable to the current call\r\n     * @return safe The safe whose FallbackManager is making this call\r\n     * @return sender The original `msg.sender` (as received by the FallbackManager)\r\n     * @return isStatic Whether the method is static (`view`) or not\r\n     * @return handler the address of the handler contract\r\n     */\r\n    function _getContextAndHandler() internal view returns (ISafe safe, address sender, bool isStatic, address handler) {\r\n        (safe, sender) = _getContext();\r\n        (isStatic, handler) = MarshalLib.decode(safeMethods[safe][msg.sig]);\r\n    }\r\n}\r\n"
      },
      "project/contracts/handler/extensible/FallbackHandler.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {ISafe, IStaticFallbackMethod, IFallbackMethod, ExtensibleBase} from \"./ExtensibleBase.sol\";\r\n\r\ninterface IFallbackHandler {\r\n    function setSafeMethod(bytes4 selector, bytes32 newMethod) external;\r\n}\r\n\r\n/**\r\n * @title FallbackHandler - A fully extensible fallback handler for Safes\r\n * @dev This contract provides a fallback handler for Safes that can be extended with custom fallback handlers\r\n *      for specific methods.\r\n * @author mfw78 <mfw78@rndlabs.xyz>\r\n */\r\nabstract contract FallbackHandler is ExtensibleBase, IFallbackHandler {\r\n    // --- setters ---\r\n\r\n    /**\r\n     * Setter for custom method handlers\r\n     * @param selector The `bytes4` selector of the method to set the handler for\r\n     * @param newMethod A contract that implements the `IFallbackMethod` or `IStaticFallbackMethod` interface\r\n     */\r\n    function setSafeMethod(bytes4 selector, bytes32 newMethod) public override onlySelf {\r\n        _setSafeMethod(ISafe(payable(_msgSender())), selector, newMethod);\r\n    }\r\n\r\n    // --- fallback ---\r\n\r\n    // solhint-disable-next-line\r\n    fallback(bytes calldata) external returns (bytes memory result) {\r\n        require(msg.data.length >= 24, \"invalid method selector\");\r\n        (ISafe safe, address sender, bool isStatic, address handler) = _getContextAndHandler();\r\n        require(handler != address(0), \"method handler not set\");\r\n\r\n        if (isStatic) {\r\n            result = IStaticFallbackMethod(handler).handle(safe, sender, 0, msg.data[:msg.data.length - 20]);\r\n        } else {\r\n            result = IFallbackMethod(handler).handle(safe, sender, 0, msg.data[:msg.data.length - 20]);\r\n        }\r\n    }\r\n}\r\n"
      },
      "project/contracts/handler/extensible/MarshalLib.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nlibrary MarshalLib {\r\n    /**\r\n     * Encode a method handler into a `bytes32` value\r\n     * @dev The first byte of the `bytes32` value is set to 0x01 if the method is not static (`view`)\r\n     * @dev The last 20 bytes of the `bytes32` value are set to the address of the handler contract\r\n     * @param isStatic Whether the method is static (`view`) or not\r\n     * @param handler The address of the handler contract implementing the `IFallbackMethod` or `IStaticFallbackMethod` interface\r\n     */\r\n    function encode(bool isStatic, address handler) internal pure returns (bytes32 data) {\r\n        data = bytes32(uint256(uint160(handler)) | (isStatic ? 0 : (1 << 248)));\r\n    }\r\n\r\n    /**\r\n     * Encode a method handler into a `bytes32` value with a selector\r\n     * @dev The first byte of the `bytes32` value is set to 0x01 if the method is not static (`view`)\r\n     * @dev The next 4 bytes of the `bytes32` value are set to the selector of the method\r\n     * @dev The last 20 bytes of the `bytes32` value are set to the address of the handler contract\r\n     * @param isStatic Whether the method is static (`view`) or not\r\n     * @param selector The selector of the method\r\n     * @param handler The address of the handler contract implementing the `IFallbackMethod` or `IStaticFallbackMethod` interface\r\n     */\r\n    function encodeWithSelector(bool isStatic, bytes4 selector, address handler) internal pure returns (bytes32 data) {\r\n        data = bytes32(uint256(uint160(handler)) | (isStatic ? 0 : (1 << 248)) | (uint256(uint32(selector)) << 216));\r\n    }\r\n\r\n    /**\r\n     * Given a `bytes32` value, decode it into a method handler and return it\r\n     * @param data The packed data to decode\r\n     * @return isStatic Whether the method is static (`view`) or not\r\n     * @return handler The address of the handler contract implementing the `IFallbackMethod` or `IStaticFallbackMethod` interface\r\n     */\r\n    function decode(bytes32 data) internal pure returns (bool isStatic, address handler) {\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // set isStatic to true if the left-most byte of the data is 0x00\r\n            isStatic := iszero(shr(248, data))\r\n            handler := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n    }\r\n\r\n    /**\r\n     * Given a `bytes32` value, decode it into a method handler and return it\r\n     * @param data The packed data to decode\r\n     * @return isStatic Whether the method is static (`view`) or not\r\n     * @return selector The selector of the method\r\n     * @return handler The address of the handler contract implementing the `IFallbackMethod` or `IStaticFallbackMethod` interface\r\n     */\r\n    function decodeWithSelector(bytes32 data) internal pure returns (bool isStatic, bytes4 selector, address handler) {\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // set isStatic to true if the left-most byte of the data is 0x00\r\n            isStatic := iszero(shr(248, data))\r\n            handler := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            selector := shl(168, shr(160, data))\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n    }\r\n}\r\n"
      },
      "project/contracts/handler/extensible/SignatureVerifierMuxer.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\n// solhint-disable one-contract-per-file\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {ISafe, ExtensibleBase} from \"./ExtensibleBase.sol\";\r\n\r\ninterface ERC1271 {\r\n    function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);\r\n}\r\n\r\n/**\r\n * @title Safe Signature Verifier Interface\r\n * @author mfw78 <mfw78@rndlabs.xyz>\r\n * @notice This interface provides a standard for external contracts that verify signatures\r\n *         for a Safe.\r\n */\r\ninterface ISafeSignatureVerifier {\r\n    /**\r\n     * @dev If called by `SignatureVerifierMuxer`, the following has already been checked:\r\n     *      _hash = h(abi.encodePacked(\"\\x19\\x01\", domainSeparator, h(typeHash || encodeData)));\r\n     * @param safe The Safe that has delegated the signature verification\r\n     * @param sender The address that originally called the Safe's `isValidSignature` method\r\n     * @param _hash The EIP-712 hash whose signature will be verified\r\n     * @param domainSeparator The EIP-712 domainSeparator\r\n     * @param typeHash The EIP-712 typeHash\r\n     * @param encodeData The EIP-712 encoded data\r\n     * @param payload An arbitrary payload that can be used to pass additional data to the verifier\r\n     * @return magic The magic value that should be returned if the signature is valid (0x1626ba7e)\r\n     */\r\n    function isValidSafeSignature(\r\n        ISafe safe,\r\n        address sender,\r\n        bytes32 _hash,\r\n        bytes32 domainSeparator,\r\n        bytes32 typeHash,\r\n        bytes calldata encodeData,\r\n        bytes calldata payload\r\n    ) external view returns (bytes4 magic);\r\n}\r\n\r\ninterface ISignatureVerifierMuxer {\r\n    function domainVerifiers(ISafe safe, bytes32 domainSeparator) external view returns (ISafeSignatureVerifier);\r\n\r\n    function setDomainVerifier(bytes32 domainSeparator, ISafeSignatureVerifier verifier) external;\r\n}\r\n\r\n/**\r\n * @title ERC-1271 Signature Verifier Multiplexer (Muxer)\r\n * @author mfw78 <mfw78@rndlabs.xyz>\r\n * @notice Allows delegating EIP-712 domains to an arbitrary `ISafeSignatureVerifier`\r\n * @dev This multiplexer enforces a strict authorisation per domainSeparator. This is to prevent a malicious\r\n *     `ISafeSignatureVerifier` from being able to verify signatures for any domainSeparator. This does not prevent\r\n *      an `ISafeSignatureVerifier` from being able to verify signatures for multiple domainSeparators, however\r\n *      each domainSeparator requires specific approval by Safe.\r\n */\r\nabstract contract SignatureVerifierMuxer is ExtensibleBase, ERC1271, ISignatureVerifierMuxer {\r\n    // --- constants ---\r\n    // keccak256(\"SafeMessage(bytes message)\");\r\n    bytes32 private constant SAFE_MSG_TYPEHASH = 0x60b3cbf8b4a223d68d641b3b6ddf9a298e7f33710cf3d3a9d1146b5a6150fbca;\r\n    // keccak256(\"safeSignature(bytes32,bytes32,bytes,bytes)\");\r\n    bytes4 private constant SAFE_SIGNATURE_MAGIC_VALUE = 0x5fd7e97d;\r\n\r\n    // --- storage ---\r\n    mapping(ISafe => mapping(bytes32 => ISafeSignatureVerifier)) public override domainVerifiers;\r\n\r\n    // --- events ---\r\n    event ChangedDomainVerifier(\r\n        ISafe indexed safe,\r\n        bytes32 domainSeparator,\r\n        ISafeSignatureVerifier oldVerifier,\r\n        ISafeSignatureVerifier newVerifier\r\n    );\r\n\r\n    /**\r\n     * Setter for the signature muxer\r\n     * @param domainSeparator The domainSeparator authorised for the `ISafeSignatureVerifier`\r\n     * @param newVerifier A contract that implements `ISafeSignatureVerifier`\r\n     */\r\n    function setDomainVerifier(bytes32 domainSeparator, ISafeSignatureVerifier newVerifier) public override onlySelf {\r\n        ISafe safe = ISafe(payable(_msgSender()));\r\n        ISafeSignatureVerifier oldVerifier = domainVerifiers[safe][domainSeparator];\r\n        domainVerifiers[safe][domainSeparator] = newVerifier;\r\n        emit ChangedDomainVerifier(safe, domainSeparator, oldVerifier, newVerifier);\r\n    }\r\n\r\n    /**\r\n     * @notice Implements ERC1271 interface for smart contract EIP-712 signature validation\r\n     * @dev The signature format is the same as the one used by the Safe contract\r\n     * @param _hash Hash of the data that is signed\r\n     * @param signature The signature to be verified\r\n     * @return magic Standardised ERC1271 return value\r\n     */\r\n    function isValidSignature(bytes32 _hash, bytes calldata signature) external view override returns (bytes4 magic) {\r\n        (ISafe safe, address sender) = _getContext();\r\n\r\n        // Check if the signature is for an `ISafeSignatureVerifier` and if it is valid for the domain.\r\n        if (signature.length >= 4) {\r\n            bytes4 sigSelector;\r\n            /* solhint-disable no-inline-assembly */\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                sigSelector := calldataload(signature.offset)\r\n            }\r\n            /* solhint-enable no-inline-assembly */\r\n\r\n            // Guard against short signatures that would cause abi.decode to revert.\r\n            if (sigSelector == SAFE_SIGNATURE_MAGIC_VALUE && signature.length >= 68) {\r\n                // Signature is for an `ISafeSignatureVerifier` - decode the signature.\r\n                // Layout of the `signature`:\r\n                // 0x00 to 0x04: selector\r\n                // 0x04 to 0x24: domainSeparator\r\n                // 0x24 to 0x44: typeHash\r\n                // 0x44 to 0x64: encodeData.offset\r\n                // 0x64 to 0x84: payload.offset\r\n                // encodeData.offset to encodeData.offset+0x20: encodeData.length\r\n                // encodeData.offset+0x20 to encodeData.offset+0x20+encodeData.length: encodeData\r\n                // payload.offset to payload.offset+0x20: payload.length\r\n                // payload.offset+0x20 to payload.offset+0x20+payload.length: payload\r\n                //\r\n                // Get the domainSeparator from the signature.\r\n                (bytes32 domainSeparator, bytes32 typeHash) = abi.decode(signature[4:68], (bytes32, bytes32));\r\n\r\n                ISafeSignatureVerifier verifier = domainVerifiers[safe][domainSeparator];\r\n                // Check if there is an `ISafeSignatureVerifier` for the domain.\r\n                if (address(verifier) != address(0)) {\r\n                    (, , bytes memory encodeData, bytes memory payload) = abi.decode(signature[4:], (bytes32, bytes32, bytes, bytes));\r\n\r\n                    // Check that the signature is valid for the domain.\r\n                    if (keccak256(EIP712.encodeMessageData(domainSeparator, typeHash, encodeData)) == _hash) {\r\n                        // Preserving the context, call the Safe's authorised `ISafeSignatureVerifier` to verify.\r\n                        return verifier.isValidSafeSignature(safe, sender, _hash, domainSeparator, typeHash, encodeData, payload);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // domainVerifier doesn't exist or the signature is invalid for the domain - fall back to the default\r\n        return defaultIsValidSignature(safe, _hash, signature);\r\n    }\r\n\r\n    /**\r\n     * Default Safe signature validation (approved hashes/threshold signatures)\r\n     * @param safe The safe being asked to validate the signature\r\n     * @param _hash Hash of the data that is signed\r\n     * @param signature The signature to be verified\r\n     */\r\n    function defaultIsValidSignature(ISafe safe, bytes32 _hash, bytes memory signature) internal view returns (bytes4 magic) {\r\n        bytes memory messageData = EIP712.encodeMessageData(\r\n            safe.domainSeparator(),\r\n            SAFE_MSG_TYPEHASH,\r\n            abi.encode(keccak256(abi.encode(_hash)))\r\n        );\r\n        bytes32 messageHash = keccak256(messageData);\r\n        if (signature.length == 0) {\r\n            // approved hashes\r\n            require(safe.signedMessages(messageHash) != 0, \"Hash not approved\");\r\n        } else {\r\n            // threshold signatures\r\n            safe.checkSignatures(address(0), messageHash, signature);\r\n        }\r\n        magic = ERC1271.isValidSignature.selector;\r\n    }\r\n}\r\n\r\nlibrary EIP712 {\r\n    function encodeMessageData(bytes32 domainSeparator, bytes32 typeHash, bytes memory message) internal pure returns (bytes memory) {\r\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator, keccak256(abi.encodePacked(typeHash, message)));\r\n    }\r\n}\r\n"
      },
      "project/contracts/handler/extensible/TokenCallbacks.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {ERC1155TokenReceiver} from \"../../interfaces/ERC1155TokenReceiver.sol\";\r\nimport {ERC721TokenReceiver} from \"../../interfaces/ERC721TokenReceiver.sol\";\r\n\r\nimport {ExtensibleBase} from \"./ExtensibleBase.sol\";\r\n\r\n/**\r\n * @title TokenCallbacks - ERC-1155 and ERC-721 token callbacks for Safes\r\n * @author mfw78 <mfw78@rndlabs.xyz>\r\n * @notice Refactored from https://github.com/safe-global/safe-contracts/blob/3c3fc80f7f9aef1d39aaae2b53db5f4490051b0d/contracts/handler/TokenCallbackHandler.sol\r\n */\r\nabstract contract TokenCallbacks is ExtensibleBase, ERC1155TokenReceiver, ERC721TokenReceiver {\r\n    /**\r\n     * @notice Handles ERC-1155 Token callback.\r\n     * return Standardized onERC1155Received return value.\r\n     */\r\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external view override onlyFallback returns (bytes4) {\r\n        // Else return the standard value\r\n        return 0xf23a6e61;\r\n    }\r\n\r\n    /**\r\n     * @notice Handles ERC-1155 Token batch callback.\r\n     * return Standardized onERC1155BatchReceived return value.\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] calldata,\r\n        uint256[] calldata,\r\n        bytes calldata\r\n    ) external view override onlyFallback returns (bytes4) {\r\n        // Else return the standard value\r\n        return 0xbc197c81;\r\n    }\r\n\r\n    /**\r\n     * @notice Handles ERC-721 Token callback.\r\n     *  return Standardized onERC721Received return value.\r\n     */\r\n    function onERC721Received(address, address, uint256, bytes calldata) external view override onlyFallback returns (bytes4) {\r\n        // Else return the standard value\r\n        return 0x150b7a02;\r\n    }\r\n}\r\n"
      },
      "project/contracts/handler/ExtensibleFallbackHandler.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {ERC165Handler} from \"./extensible/ERC165Handler.sol\";\r\nimport {IFallbackHandler, FallbackHandler} from \"./extensible/FallbackHandler.sol\";\r\nimport {ERC1271, ISignatureVerifierMuxer, SignatureVerifierMuxer} from \"./extensible/SignatureVerifierMuxer.sol\";\r\nimport {ERC721TokenReceiver, ERC1155TokenReceiver, TokenCallbacks} from \"./extensible/TokenCallbacks.sol\";\r\n\r\n/**\r\n * @title ExtensibleFallbackHandler - A fully extensible fallback handler for Safes\r\n * @dev Designed to be used with Safe >= 1.3.0.\r\n * @author mfw78 <mfw78@rndlabs.xyz>\r\n */\r\ncontract ExtensibleFallbackHandler is FallbackHandler, SignatureVerifierMuxer, TokenCallbacks, ERC165Handler {\r\n    /**\r\n     * Specify specific interfaces (ERC721 + ERC1155) that this contract supports.\r\n     * @param interfaceId The interface ID to check for support\r\n     */\r\n    function _supportsInterface(bytes4 interfaceId) internal pure override returns (bool) {\r\n        return\r\n            interfaceId == type(ERC721TokenReceiver).interfaceId ||\r\n            interfaceId == type(ERC1155TokenReceiver).interfaceId ||\r\n            interfaceId == type(ERC1271).interfaceId ||\r\n            interfaceId == type(ISignatureVerifierMuxer).interfaceId ||\r\n            interfaceId == type(ERC165Handler).interfaceId ||\r\n            interfaceId == type(IFallbackHandler).interfaceId;\r\n    }\r\n}\r\n"
      },
      "project/contracts/handler/HandlerContext.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {ISafe} from \"../interfaces/ISafe.sol\";\r\n\r\n/**\r\n * @title Handler Context - Allows the fallback handler to extract additional context from the calldata\r\n * @dev The fallback manager appends the following context to the calldata:\r\n *      1. Fallback manager caller address (non-padded)\r\n * based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/f8cc8b844a9f92f63dc55aa581f7d643a1bc5ac1/contracts/metatx/ERC2771Context.sol\r\n * @author Richard Meissner - @rmeissner\r\n */\r\nabstract contract HandlerContext {\r\n    /**\r\n     * @dev The storage slot used for storing the currently configured fallback handler address.\r\n     *      Precomputed value of: `keccak256(\"fallback_manager.handler.address\")`.\r\n     */\r\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\r\n\r\n    /**\r\n     * @notice A modifier that reverts if not called by a Safe as a fallback handler.\r\n     * @dev Note that this modifier does a **best effort** attempt at not allowing calls that are\r\n     *      not as a fallback call, but it still can be tricked. It is suitable for use cases such\r\n     *      making a best effort attempt to disallow ERC-721 and ERC-1155 token transfers to the\r\n     *      fallback handler contract.\r\n     */\r\n    modifier onlyFallback() {\r\n        _requireFallback();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Implementation of the {onlySafeFallback} modifier check that the current call is a Safe\r\n     *      fallback call, and the contract is not called directly. Note that this is only a **best\r\n     *      effort** check and may generate false positives under certain conditions.\r\n     */\r\n    function _requireFallback() internal view {\r\n        bytes memory storageData = ISafe(payable(msg.sender)).getStorageAt(uint256(FALLBACK_HANDLER_STORAGE_SLOT), 1);\r\n        address fallbackHandler = abi.decode(storageData, (address));\r\n        require(fallbackHandler == address(this), \"not a fallback call\");\r\n    }\r\n\r\n    /**\r\n     * @notice Allows fetching the original caller address.\r\n     * @dev This is only reliable in combination with a FallbackManager that supports this (e.g. Safe contract >=1.3.0).\r\n     *      When using this functionality make sure that the linked _manager (aka msg.sender) supports this.\r\n     *      This function does not rely on a trusted forwarder. Use the returned value only to\r\n     *      check information against the calling manager.\r\n     * @return sender Original caller address.\r\n     */\r\n    function _msgSender() internal pure returns (address sender) {\r\n        require(msg.data.length >= 20, \"Invalid calldata length\");\r\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the FallbackManager address\r\n     * @return Fallback manager address\r\n     */\r\n    function _manager() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n"
      },
      "project/contracts/interfaces/ERC1155TokenReceiver.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n// Note: The ERC-165 identifier for this interface is 0x4e2312e0.\r\ninterface ERC1155TokenReceiver {\r\n    /**\r\n     * @notice Handle the receipt of a single ERC1155 token type.\r\n     * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *      This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\r\n     *      This function MUST revert if it rejects the transfer.\r\n     *      Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\r\n     * @param _operator  The address which initiated the transfer (i.e. msg.sender).\r\n     * @param _from      The address which previously owned the token.\r\n     * @param _id        The ID of the token being transferred.\r\n     * @param _value     The amount of tokens being transferred.\r\n     * @param _data      Additional data with no specified format.\r\n     * @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`.\r\n     */\r\n    function onERC1155Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _id,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @notice Handle the receipt of multiple ERC1155 token types.\r\n     * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\r\n     *      This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\r\n     *      This function MUST revert if it rejects the transfer(s).\r\n     *      Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\r\n     * @param _operator  The address which initiated the batch transfer (i.e. msg.sender).\r\n     * @param _from      The address which previously owned the token.\r\n     * @param _ids       An array containing ids of each token being transferred (order and length must match _values array).\r\n     * @param _values    An array containing amounts of each token being transferred (order and length must match _ids array).\r\n     * @param _data      Additional data with no specified format.\r\n     * @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`.\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address _operator,\r\n        address _from,\r\n        uint256[] calldata _ids,\r\n        uint256[] calldata _values,\r\n        bytes calldata _data\r\n    ) external returns (bytes4);\r\n}\r\n"
      },
      "project/contracts/interfaces/ERC721TokenReceiver.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface ERC721TokenReceiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     *  after a `transfer`. This function MAY throw to revert and reject the\r\n     *  transfer. Return of other than the magic value MUST result in the\r\n     *  transaction being reverted.\r\n     *  Note: the contract address is always the message sender.\r\n     * @param _operator The address which called `safeTransferFrom` function.\r\n     * @param _from The address which previously owned the token.\r\n     * @param _tokenId The NFT identifier which is being transferred.\r\n     * @param _data Additional data with no specified format.\r\n     * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n     *  unless throwing\r\n     */\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);\r\n}\r\n"
      },
      "project/contracts/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/// @notice More details at https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by `interfaceId`.\r\n     * See the corresponding EIP section\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n"
      },
      "project/contracts/interfaces/IFallbackManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title IFallbackManager - A contract interface managing fallback calls made to this contract.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IFallbackManager {\r\n    event ChangedFallbackHandler(address indexed handler);\r\n\r\n    /**\r\n     * @notice Set Fallback Handler to `handler` for the Safe.\r\n     * @dev 1. Only fallback calls without value and with data will be forwarded.\r\n     *      2. Changing the fallback handler can only be done via a Safe transaction.\r\n     *      3. Cannot be set to the Safe itself.\r\n     *      4. IMPORTANT! SECURITY RISK! The fallback handler can be set to any address and all the calls will be forwarded to it,\r\n     *         bypassing all the Safe's access control mechanisms. When setting the fallback handler, make sure to check the address\r\n     *         is a trusted contract and if it supports state changes, it implements the necessary checks.\r\n     * @param handler contract to handle fallback calls.\r\n     */\r\n    function setFallbackHandler(address handler) external;\r\n\r\n    /**\r\n     * @notice Forwards all calls to the fallback handler if set.\r\n     *         Returns empty data if no handler is set.\r\n     * @dev Appends the non-padded caller address to the calldata to be optionally used in the handler\r\n     *      The handler can make use of {HandlerContext} to extract the address.\r\n     *      This is done because in the next call frame the `msg.sender` will be {FallbackManager}'s address\r\n     *      and having the original caller address may enable additional verification scenarios.\r\n     */\r\n    fallback() external;\r\n}\r\n"
      },
      "project/contracts/interfaces/IGuardManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\n/* solhint-disable one-contract-per-file */\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title IGuardManager - A contract interface managing transaction guards which perform pre and post-checks on Safe transactions.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IGuardManager {\r\n    event ChangedGuard(address indexed guard);\r\n\r\n    /**\r\n     * @dev Set a guard that checks transactions before execution\r\n     *      This can only be done via a Safe transaction.\r\n     *      ⚠️ IMPORTANT: Since a guard has full power to block Safe transaction execution,\r\n     *        a broken guard can cause a denial of service for the Safe. Make sure to carefully\r\n     *        audit the guard code and design recovery mechanisms.\r\n     * @notice Set Transaction Guard `guard` for the Safe. Make sure you trust the guard.\r\n     * @param guard The address of the guard to be used or the 0 address to disable the guard\r\n     */\r\n    function setGuard(address guard) external;\r\n}\r\n"
      },
      "project/contracts/interfaces/IModuleManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\nimport {Enum} from \"../libraries/Enum.sol\";\r\n\r\n/**\r\n * @title IModuleManager - An interface of contract managing Safe modules\r\n * @notice Modules are extensions with unlimited access to a Safe that can be added to a Safe by its owners.\r\n           ⚠️ WARNING: Modules are a security risk since they can execute arbitrary transactions, \r\n           so only trusted and audited modules should be added to a Safe. A malicious module can\r\n           completely takeover a Safe.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IModuleManager {\r\n    event EnabledModule(address indexed module);\r\n    event DisabledModule(address indexed module);\r\n    event ExecutionFromModuleSuccess(address indexed module);\r\n    event ExecutionFromModuleFailure(address indexed module);\r\n    event ChangedModuleGuard(address indexed moduleGuard);\r\n\r\n    /**\r\n     * @notice Enables the module `module` for the Safe.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param module Module to be whitelisted.\r\n     */\r\n    function enableModule(address module) external;\r\n\r\n    /**\r\n     * @notice Disables the module `module` for the Safe.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param prevModule Previous module in the modules linked list.\r\n     * @param module Module to be removed.\r\n     */\r\n    function disableModule(address prevModule, address module) external;\r\n\r\n    /**\r\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token)\r\n     * @param to Destination address of module transaction.\r\n     * @param value Ether value of module transaction.\r\n     * @param data Data payload of module transaction.\r\n     * @param operation Operation type of module transaction.\r\n     * @return success Boolean flag indicating if the call succeeded.\r\n     */\r\n    function execTransactionFromModule(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation\r\n    ) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token) and return data\r\n     * @param to Destination address of module transaction.\r\n     * @param value Ether value of module transaction.\r\n     * @param data Data payload of module transaction.\r\n     * @param operation Operation type of module transaction.\r\n     * @return success Boolean flag indicating if the call succeeded.\r\n     * @return returnData Data returned by the call.\r\n     */\r\n    function execTransactionFromModuleReturnData(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation\r\n    ) external returns (bool success, bytes memory returnData);\r\n\r\n    /**\r\n     * @notice Returns if a module is enabled\r\n     * @return True if the module is enabled\r\n     */\r\n    function isModuleEnabled(address module) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns an array of modules.\r\n     *         If all entries fit into a single page, the next pointer will be 0x1.\r\n     *         If another page is present, next will be the last element of the returned array.\r\n     * @param start Start of the page. Has to be a module or start pointer (0x1 address)\r\n     * @param pageSize Maximum number of modules that should be returned. Has to be > 0\r\n     * @return array Array of modules.\r\n     * @return next Start of the next page.\r\n     */\r\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next);\r\n\r\n    /**\r\n     * @dev Set a module guard that checks transactions initiated by the module before execution\r\n     *      This can only be done via a Safe transaction.\r\n     *      ⚠️ IMPORTANT: Since a module guard has full power to block Safe transaction execution initiated via a module,\r\n     *        a broken module guard can cause a denial of service for the Safe modules. Make sure to carefully\r\n     *        audit the module guard code and design recovery mechanisms.\r\n     * @notice Set Module Guard `moduleGuard` for the Safe. Make sure you trust the module guard.\r\n     * @param moduleGuard The address of the module guard to be used or the zero address to disable the module guard.\r\n     */\r\n    function setModuleGuard(address moduleGuard) external;\r\n}\r\n"
      },
      "project/contracts/interfaces/INativeCurrencyPaymentFallback.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title Native Currency Payment Fallback Interface\r\n * @notice An interface to a contract that can receive native currency payments.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface INativeCurrencyPaymentFallback {\r\n    event SafeReceived(address indexed sender, uint256 value);\r\n\r\n    /**\r\n     * @notice Receive function accepts native currency transactions.\r\n     * @dev Emits an event with sender and received value.\r\n     */\r\n    receive() external payable;\r\n}\r\n"
      },
      "project/contracts/interfaces/IOwnerManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title IOwnerManager - Interface for contract which manages Safe owners and a threshold to authorize transactions.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IOwnerManager {\r\n    event AddedOwner(address indexed owner);\r\n    event RemovedOwner(address indexed owner);\r\n    event ChangedThreshold(uint256 threshold);\r\n\r\n    /**\r\n     * @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param owner New owner address.\r\n     * @param _threshold New threshold.\r\n     */\r\n    function addOwnerWithThreshold(address owner, uint256 _threshold) external;\r\n\r\n    /**\r\n     * @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param prevOwner Owner that pointed to the owner to be removed in the linked list\r\n     * @param owner Owner address to be removed.\r\n     * @param _threshold New threshold.\r\n     */\r\n    function removeOwner(address prevOwner, address owner, uint256 _threshold) external;\r\n\r\n    /**\r\n     * @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param prevOwner Owner that pointed to the owner to be replaced in the linked list\r\n     * @param oldOwner Owner address to be replaced.\r\n     * @param newOwner New owner address.\r\n     */\r\n    function swapOwner(address prevOwner, address oldOwner, address newOwner) external;\r\n\r\n    /**\r\n     * @notice Changes the threshold of the Safe to `_threshold`.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param _threshold New threshold.\r\n     */\r\n    function changeThreshold(uint256 _threshold) external;\r\n\r\n    /**\r\n     * @notice Returns the number of required confirmations for a Safe transaction aka the threshold.\r\n     * @return Threshold number.\r\n     */\r\n    function getThreshold() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns if `owner` is an owner of the Safe.\r\n     * @return Boolean if `owner` is an owner of the Safe.\r\n     */\r\n    function isOwner(address owner) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns a list of Safe owners.\r\n     * @return Array of Safe owners.\r\n     */\r\n    function getOwners() external view returns (address[] memory);\r\n}\r\n"
      },
      "project/contracts/interfaces/ISafe.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {Enum} from \"./../libraries/Enum.sol\";\r\nimport {IFallbackManager} from \"./IFallbackManager.sol\";\r\nimport {IGuardManager} from \"./IGuardManager.sol\";\r\nimport {IModuleManager} from \"./IModuleManager.sol\";\r\nimport {INativeCurrencyPaymentFallback} from \"./INativeCurrencyPaymentFallback.sol\";\r\nimport {IOwnerManager} from \"./IOwnerManager.sol\";\r\nimport {IStorageAccessible} from \"./IStorageAccessible.sol\";\r\n\r\n/**\r\n * @title ISafe - A multisignature wallet interface with support for confirmations using signed messages based on EIP-712.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface ISafe is INativeCurrencyPaymentFallback, IModuleManager, IGuardManager, IOwnerManager, IFallbackManager, IStorageAccessible {\r\n    event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);\r\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\r\n    event SignMsg(bytes32 indexed msgHash);\r\n    event ExecutionFailure(bytes32 indexed txHash, uint256 payment);\r\n    event ExecutionSuccess(bytes32 indexed txHash, uint256 payment);\r\n\r\n    /**\r\n     * @notice Sets an initial storage of the Safe contract.\r\n     * @dev This method can only be called once.\r\n     *      If a proxy was created without setting up, anyone can call setup and claim the proxy.\r\n     *      This method emits a {SafeSetup} event with the setup parameters instead of reading from storage,\r\n     *      which may be inaccurate if the delegate call to `to` modifies the owners, threshold or fallback handler.\r\n     * @param _owners List of Safe owners.\r\n     * @param _threshold Number of required confirmations for a Safe transaction.\r\n     * @param to Contract address for optional delegate call.\r\n     * @param data Data payload for optional delegate call.\r\n     * @param fallbackHandler Handler for fallback calls to this contract\r\n     * @param paymentToken Token that should be used for the payment (0 is ETH)\r\n     * @param payment Value that should be paid\r\n     * @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)\r\n     */\r\n    function setup(\r\n        address[] calldata _owners,\r\n        uint256 _threshold,\r\n        address to,\r\n        bytes calldata data,\r\n        address fallbackHandler,\r\n        address paymentToken,\r\n        uint256 payment,\r\n        address payable paymentReceiver\r\n    ) external;\r\n\r\n    /** @notice Executes a `operation` {0: Call, 1: DelegateCall} transaction to `to` with `value` (Native Currency)\r\n     *          and pays `gasPrice` * `gasLimit` in `gasToken` token to `refundReceiver`.\r\n     * @dev The fees are always transferred, even if the user transaction fails.\r\n     *      This method doesn't perform any sanity check of the transaction, such as:\r\n     *      - if the contract at `to` address has code or not\r\n     *      - if the `gasToken` is a contract or not\r\n     *      It is the responsibility of the caller to perform such checks.\r\n     * @param to Destination address of Safe transaction.\r\n     * @param value Ether value of Safe transaction.\r\n     * @param data Data payload of Safe transaction.\r\n     * @param operation Operation type of Safe transaction.\r\n     * @param safeTxGas Gas that should be used for the Safe transaction.\r\n     * @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\r\n     * @param gasPrice Gas price that should be used for the payment calculation.\r\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n     * @param signatures Signature data that should be verified.\r\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\r\n     * @return success Boolean indicating transaction's success.\r\n     */\r\n    function execTransaction(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address payable refundReceiver,\r\n        bytes memory signatures\r\n    ) external payable returns (bool success);\r\n\r\n    /**\r\n     * @notice Checks whether the signature provided is valid for the provided data and hash and executor. Reverts otherwise.\r\n     * @param executor Address that executes the transaction.\r\n     *        ⚠️⚠️⚠️ Make sure that the executor address is a legitimate executor.\r\n     *        Incorrectly passed the executor might reduce the threshold by 1 signature. ⚠️⚠️⚠️\r\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\r\n     * @param signatures Signature data that should be verified.\r\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\r\n     */\r\n    function checkSignatures(address executor, bytes32 dataHash, bytes memory signatures) external view;\r\n\r\n    /**\r\n     * @notice Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.\r\n     * @dev Since the EIP-1271 does an external call, be mindful of reentrancy attacks.\r\n     * @param executor Address that executes the transaction.\r\n     *        ⚠️⚠️⚠️ Make sure that the executor address is a legitimate executor.\r\n     *        Incorrectly passed the executor might reduce the threshold by 1 signature. ⚠️⚠️⚠️\r\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\r\n     * @param signatures Signature data that should be verified.\r\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\r\n     * @param requiredSignatures Amount of required valid signatures.\r\n     */\r\n    function checkNSignatures(address executor, bytes32 dataHash, bytes memory signatures, uint256 requiredSignatures) external view;\r\n\r\n    /**\r\n     * @notice Marks hash `hashToApprove` as approved.\r\n     * @dev This can be used with a pre-approved hash transaction signature.\r\n     *      IMPORTANT: The approved hash stays approved forever. There's no revocation mechanism, so it behaves similarly to ECDSA signatures\r\n     * @param hashToApprove The hash to mark as approved for signatures that are verified by this contract.\r\n     */\r\n    function approveHash(bytes32 hashToApprove) external;\r\n\r\n    /**\r\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\r\n     * @return bytes32 The domain separator hash.\r\n     */\r\n    function domainSeparator() external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Returns transaction hash to be signed by owners.\r\n     * @param to Destination address.\r\n     * @param value Ether value.\r\n     * @param data Data payload.\r\n     * @param operation Operation type.\r\n     * @param safeTxGas Gas that should be used for the safe transaction.\r\n     * @param baseGas Gas costs for data used to trigger the safe transaction.\r\n     * @param gasPrice Maximum gas price that should be used for this transaction.\r\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n     * @param _nonce Transaction nonce.\r\n     * @return Transaction hash.\r\n     */\r\n    function getTransactionHash(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address refundReceiver,\r\n        uint256 _nonce\r\n    ) external view returns (bytes32);\r\n\r\n    /**\r\n     * External getter function for state variables.\r\n     */\r\n\r\n    /**\r\n     * @notice Returns the version of the Safe contract.\r\n     * @return Version string.\r\n     */\r\n    // solhint-disable-next-line\r\n    function VERSION() external view returns (string memory);\r\n\r\n    /**\r\n     * @notice Returns the nonce of the Safe contract.\r\n     * @return Nonce.\r\n     */\r\n    function nonce() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns a uint if the messageHash is signed by the owner.\r\n     * @param messageHash Hash of message that should be checked.\r\n     * @return Number denoting if an owner signed the hash.\r\n     */\r\n    function signedMessages(bytes32 messageHash) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns a uint if the messageHash is approved by the owner.\r\n     * @param owner Owner address that should be checked.\r\n     * @param messageHash Hash of message that should be checked.\r\n     * @return Number denoting if an owner approved the hash.\r\n     */\r\n    function approvedHashes(address owner, bytes32 messageHash) external view returns (uint256);\r\n}\r\n"
      },
      "project/contracts/interfaces/IStorageAccessible.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title Storage Accessible Interface\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IStorageAccessible {\r\n    /**\r\n     * @notice Reads `length` bytes of storage in the current contract\r\n     * @param offset The offset in the current contract's storage in words to start reading from.\r\n     * @param length The number of words (32 bytes) of data to read.\r\n     * @return The bytes that were read.\r\n     */\r\n    function getStorageAt(uint256 offset, uint256 length) external view returns (bytes memory);\r\n\r\n    /**\r\n     * @notice Performs a `DELEGATECALL` to a `targetContract` in the context of self.\r\n     * @dev Internally reverts execution to avoid side effects (making it effectively static).\r\n     *      This method reverts with data equal to `abi.encodePacked(uint256(success), uint256(response.length), bytes(response))`.\r\n     *      Specifically, the return data after a call to this method will be:\r\n     *      `success:uint256 || response.length:uint256 || response:bytes`.\r\n     * @param targetContract Address of the contract containing the code to execute.\r\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\r\n     */\r\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external;\r\n}\r\n"
      },
      "project/contracts/libraries/Enum.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title Enum - Collection of enums used in Safe Smart Account contracts.\r\n * @author @safe-global/safe-protocol\r\n */\r\nlibrary Enum {\r\n    enum Operation {\r\n        Call,\r\n        DelegateCall\r\n    }\r\n}\r\n"
      }
    }
  }
}