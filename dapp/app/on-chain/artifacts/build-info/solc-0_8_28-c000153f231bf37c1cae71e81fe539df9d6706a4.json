{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-c000153f231bf37c1cae71e81fe539df9d6706a4",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/proxies/SafeProxyFactory.sol": "project/contracts/proxies/SafeProxyFactory.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/proxies/SafeProxy.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\n/* solhint-disable one-contract-per-file */\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title IProxy - Helper interface to access the singleton address of the Proxy on-chain.\r\n * @author Richard Meissner - @rmeissner\r\n */\r\ninterface IProxy {\r\n    function masterCopy() external view returns (address);\r\n}\r\n\r\n/**\r\n * @title SafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n * @author Stefan George - <stefan@gnosis.io>\r\n * @author Richard Meissner - <richard@gnosis.io>\r\n */\r\ncontract SafeProxy {\r\n    // Singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\r\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\r\n    address internal singleton;\r\n\r\n    /**\r\n     * @notice Constructor function sets address of singleton contract.\r\n     * @param _singleton Singleton address.\r\n     */\r\n    constructor(address _singleton) {\r\n        require(_singleton != address(0), \"Invalid singleton address provided\");\r\n        singleton = _singleton;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    fallback() external payable {\r\n        // Note that this assembly block is **intentionally** not marked as memory-safe. First of all, it isn't memory\r\n        // safe to begin with, and turning this into memory-safe assembly would just make it less gas efficient.\r\n        // Additionally, we noticed that converting this to memory-safe assembly had no affect on optimizations of other\r\n        // contracts (as it always gets compiled alone in its own compilation unit anyway). Because the assembly block\r\n        // always halts and never returns control back to Solidity, disrespecting Solidity's memory safety invariants\r\n        // is not an issue.\r\n        /* solhint-disable no-inline-assembly */\r\n        assembly {\r\n            let _singleton := sload(0)\r\n            // 0xa619486e == uint32(bytes4(keccak256(\"masterCopy()\"))). Only the 4 first bytes of calldata are\r\n            // considered to make it 100% Solidity ABI conformant.\r\n            if eq(shr(224, calldataload(0)), 0xa619486e) {\r\n                // We mask the singleton address when handling the `masterCopy()` call to ensure that it is correctly\r\n                // ABI-encoded. We do this by shifting the address left by 96 bits (or 12 bytes) and then storing it in\r\n                // memory with a 12 byte offset from where the return data starts. Note that we **intentionally** only\r\n                // do this for the `masterCopy()` call, since the EVM `DELEGATECALL` opcode ignores the most-significant\r\n                // 12 bytes from the address, so we do not need to make sure the top bytes are cleared when proxying\r\n                // calls to the `singleton`. This saves us a tiny amount of gas per proxied call. Additionally, we write\r\n                // to the \"zero-memory\" slot instead of the scratch space, which guarantees that 12 bytes of memory\r\n                // preceding the singleton address are zero (which would not be guaranteed for the scratch space) [1].\r\n                // This ensures that the data we return has the leading 12 bytes set to zero and conforms to the\r\n                // Solidity ABI [2].\r\n                //\r\n                // [1]: https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html\r\n                // [2]: https://docs.soliditylang.org/en/v0.7.6/abi-spec.html#formal-specification-of-the-encoding\r\n                mstore(0x6c, shl(96, _singleton))\r\n                return(0x60, 0x20)\r\n            }\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(\r\n                gas(),\r\n                _singleton,\r\n                0,\r\n                calldatasize(),\r\n                0,\r\n                0\r\n            )\r\n            returndatacopy(0, 0, returndatasize())\r\n            if iszero(success) {\r\n                revert(0, returndatasize())\r\n            }\r\n            return(0, returndatasize())\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n    }\r\n}\r\n"
      },
      "project/contracts/proxies/SafeProxyFactory.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {SafeProxy} from \"./SafeProxy.sol\";\r\n\r\n/**\r\n * @title Proxy Factory - Allows to create a new proxy contract and execute a message call to the new proxy within one transaction.\r\n * @author Stefan George - @Georgi87\r\n */\r\ncontract SafeProxyFactory {\r\n    event ProxyCreation(SafeProxy indexed proxy, address singleton);\r\n    event ProxyCreationL2(\r\n        SafeProxy indexed proxy,\r\n        address singleton,\r\n        bytes initializer,\r\n        uint256 saltNonce\r\n    );\r\n    event ChainSpecificProxyCreationL2(\r\n        SafeProxy indexed proxy,\r\n        address singleton,\r\n        bytes initializer,\r\n        uint256 saltNonce,\r\n        uint256 chainId\r\n    );\r\n\r\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\r\n    function proxyCreationCode() public pure returns (bytes memory) {\r\n        return type(SafeProxy).creationCode;\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method to create a new proxy contract using CREATE2. Optionally executes an initializer call to a new proxy.\r\n     * @param _singleton Address of singleton contract. Must be deployed at the time of execution.\r\n     * @param initializer (Optional) Payload for a message call to be sent to a new proxy contract.\r\n     * @param salt Create2 salt to use for calculating the address of the new proxy contract.\r\n     * @return proxy Address of the new proxy contract.\r\n     */\r\n    function deployProxy(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        bytes32 salt\r\n    ) internal returns (SafeProxy proxy) {\r\n        require(isContract(_singleton), \"Singleton contract not deployed\");\r\n\r\n        bytes memory deploymentData = abi.encodePacked(\r\n            type(SafeProxy).creationCode,\r\n            uint256(uint160(_singleton))\r\n        );\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            proxy := create2(\r\n                0x0,\r\n                add(0x20, deploymentData),\r\n                mload(deploymentData),\r\n                salt\r\n            )\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n        require(address(proxy) != address(0), \"Create2 call failed\");\r\n\r\n        if (initializer.length > 0) {\r\n            /* solhint-disable no-inline-assembly */\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                if iszero(\r\n                    call(\r\n                        gas(),\r\n                        proxy,\r\n                        0,\r\n                        add(initializer, 0x20),\r\n                        mload(initializer),\r\n                        0,\r\n                        0\r\n                    )\r\n                ) {\r\n                    let ptr := mload(0x40)\r\n                    returndatacopy(ptr, 0x00, returndatasize())\r\n                    revert(ptr, returndatasize())\r\n                }\r\n            }\r\n            /* solhint-enable no-inline-assembly */\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Deploys a new proxy with `_singleton` singleton and `saltNonce` salt. Optionally executes an initializer call to a new proxy.\r\n     * @param _singleton Address of singleton contract. Must be deployed at the time of execution.\r\n     * @param initializer Payload for a message call to be sent to a new proxy contract.\r\n     * @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n     */\r\n    function createProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) public returns (SafeProxy proxy) {\r\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatenating it\r\n        bytes32 salt = keccak256(\r\n            abi.encodePacked(keccak256(initializer), saltNonce)\r\n        );\r\n        proxy = deployProxy(_singleton, initializer, salt);\r\n        emit ProxyCreation(proxy, _singleton);\r\n    }\r\n\r\n    /**\r\n     * @notice Deploys a new proxy with `_singleton` singleton and `saltNonce` salt. Optionally executes an initializer call to a new proxy.\r\n     * @dev Emits an extra event to allow tracking of `initializer` and `saltNonce`.\r\n     * @param _singleton Address of singleton contract. Must be deployed at the time of execution.\r\n     * @param initializer Payload for a message call to be sent to a new proxy contract.\r\n     * @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n     */\r\n    function createProxyWithNonceL2(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) public returns (SafeProxy proxy) {\r\n        proxy = createProxyWithNonce(_singleton, initializer, saltNonce);\r\n        emit ProxyCreationL2(proxy, _singleton, initializer, saltNonce);\r\n    }\r\n\r\n    /**\r\n     * @notice Deploys a new chain-specific proxy with `_singleton` singleton and `saltNonce` salt. Optionally executes an initializer call to a new proxy.\r\n     * @dev Allows to create a new proxy contract that should exist only on 1 network (e.g. specific governance or admin accounts)\r\n     *      by including the chain id in the create2 salt. Such proxies cannot be created on other networks by replaying the transaction.\r\n     * @param _singleton Address of singleton contract. Must be deployed at the time of execution.\r\n     * @param initializer Payload for a message call to be sent to a new proxy contract.\r\n     * @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n     */\r\n    function createChainSpecificProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) public returns (SafeProxy proxy) {\r\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatenating it\r\n        bytes32 salt = keccak256(\r\n            abi.encodePacked(keccak256(initializer), saltNonce, getChainId())\r\n        );\r\n        proxy = deployProxy(_singleton, initializer, salt);\r\n        emit ProxyCreation(proxy, _singleton);\r\n    }\r\n\r\n    /**\r\n     * @notice Deploys a new chain-specific proxy with `_singleton` singleton and `saltNonce` salt. Optionally executes an initializer call to a new proxy.\r\n     * @dev Allows to create a new proxy contract that should exist only on 1 network (e.g. specific governance or admin accounts)\r\n     *      by including the chain id in the create2 salt. Such proxies cannot be created on other networks by replaying the transaction.\r\n     *      Emits an extra event to allow tracking of `initializer` and `saltNonce`.\r\n     * @param _singleton Address of singleton contract. Must be deployed at the time of execution.\r\n     * @param initializer Payload for a message call to be sent to a new proxy contract.\r\n     * @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n     */\r\n    function createChainSpecificProxyWithNonceL2(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) public returns (SafeProxy proxy) {\r\n        proxy = createChainSpecificProxyWithNonce(\r\n            _singleton,\r\n            initializer,\r\n            saltNonce\r\n        );\r\n        emit ChainSpecificProxyCreationL2(\r\n            proxy,\r\n            _singleton,\r\n            initializer,\r\n            saltNonce,\r\n            getChainId()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns true if `account` is a contract.\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     *      as the code is not created until after the constructor finishes.\r\n     * @param account The address being queried\r\n     * @return True if `account` is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the ID of the chain the contract is currently deployed on.\r\n     * @return The ID of the current chain as a uint256.\r\n     */\r\n    function getChainId() public view returns (uint256) {\r\n        uint256 id;\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n        return id;\r\n    }\r\n}\r\n"
      }
    }
  }
}