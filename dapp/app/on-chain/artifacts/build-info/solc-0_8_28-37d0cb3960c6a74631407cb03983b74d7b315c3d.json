{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-37d0cb3960c6a74631407cb03983b74d7b315c3d",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/examples/guards/DebugTransactionGuard.sol": "project/contracts/examples/guards/DebugTransactionGuard.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/base/Executor.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\nimport {Enum} from \"../libraries/Enum.sol\";\r\n\r\n/**\r\n * @title Executor - A contract that can execute transactions\r\n * @author Richard Meissner - @rmeissner\r\n */\r\nabstract contract Executor {\r\n    /**\r\n     * @notice Executes either a delegatecall or a call with provided parameters.\r\n     * @dev This method doesn't perform any sanity check of the transaction, such as:\r\n     *      - if the contract at `to` address has code or not\r\n     *      It is the responsibility of the caller to perform such checks.\r\n     * @param to Destination address.\r\n     * @param value Ether value.\r\n     * @param data Data payload.\r\n     * @param operation Operation type.\r\n     * @return success boolean flag indicating if the call succeeded.\r\n     */\r\n    function execute(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation,\r\n        uint256 txGas\r\n    ) internal returns (bool success) {\r\n        if (operation == Enum.Operation.DelegateCall) {\r\n            /* solhint-disable no-inline-assembly */\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\r\n            }\r\n            /* solhint-enable no-inline-assembly */\r\n        } else {\r\n            /* solhint-disable no-inline-assembly */\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\r\n            }\r\n            /* solhint-enable no-inline-assembly */\r\n        }\r\n    }\r\n}\r\n"
      },
      "project/contracts/base/GuardManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\n/* solhint-disable one-contract-per-file */\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {SelfAuthorized} from \"./../common/SelfAuthorized.sol\";\r\nimport {IERC165} from \"./../interfaces/IERC165.sol\";\r\nimport {IGuardManager} from \"./../interfaces/IGuardManager.sol\";\r\nimport {Enum} from \"./../libraries/Enum.sol\";\r\n\r\n/**\r\n * @title ITransactionGuard Interface\r\n */\r\ninterface ITransactionGuard is IERC165 {\r\n    /**\r\n     * @notice Checks the transaction details.\r\n     * @dev The function needs to implement transaction validation logic.\r\n     * @param to The address to which the transaction is intended.\r\n     * @param value The value of the transaction in Wei.\r\n     * @param data The transaction data.\r\n     * @param operation The type of operation of the transaction.\r\n     * @param safeTxGas Gas used for the transaction.\r\n     * @param baseGas The base gas for the transaction.\r\n     * @param gasPrice The price of gas in Wei for the transaction.\r\n     * @param gasToken The token used to pay for gas.\r\n     * @param refundReceiver The address which should receive the refund.\r\n     * @param signatures The signatures of the transaction.\r\n     * @param msgSender The address of the message sender.\r\n     */\r\n    function checkTransaction(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address payable refundReceiver,\r\n        bytes memory signatures,\r\n        address msgSender\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Checks after execution of the transaction.\r\n     * @dev The function needs to implement a check after the execution of the transaction.\r\n     * @param hash The hash of the transaction.\r\n     * @param success The status of the transaction execution.\r\n     */\r\n    function checkAfterExecution(bytes32 hash, bool success) external;\r\n}\r\n\r\nabstract contract BaseTransactionGuard is ITransactionGuard {\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    ) external view virtual override returns (bool) {\r\n        return\r\n            interfaceId == type(ITransactionGuard).interfaceId || // 0xe6d7a83a\r\n            interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\r\n    }\r\n}\r\n\r\n/**\r\n * @title Guard Manager - A contract managing transaction guards which perform pre and post-checks on Safe transactions.\r\n * @author Richard Meissner - @rmeissner\r\n */\r\nabstract contract GuardManager is SelfAuthorized, IGuardManager {\r\n    // keccak256(\"guard_manager.guard.address\")\r\n    bytes32 internal constant GUARD_STORAGE_SLOT =\r\n        0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\r\n\r\n    /**\r\n     * @inheritdoc IGuardManager\r\n     */\r\n    function setGuard(address guard) external override authorized {\r\n        if (\r\n            guard != address(0) &&\r\n            !ITransactionGuard(guard).supportsInterface(\r\n                type(ITransactionGuard).interfaceId\r\n            )\r\n        ) revertWithError(\"GS300\");\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            sstore(GUARD_STORAGE_SLOT, guard)\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n        emit ChangedGuard(guard);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal method to retrieve the current guard\r\n     *      We do not have a public method because we're short on bytecode size limit,\r\n     *      to retrieve the guard address, one can use `getStorageAt` from `StorageAccessible` contract\r\n     *      with the slot `GUARD_STORAGE_SLOT`\r\n     * @return guard The address of the guard\r\n     */\r\n    function getGuard() internal view returns (address guard) {\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            guard := sload(GUARD_STORAGE_SLOT)\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n    }\r\n}\r\n"
      },
      "project/contracts/base/ModuleManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\n/* solhint-disable one-contract-per-file */\r\npragma solidity >=0.7.0 <0.9.0;\r\nimport {SelfAuthorized} from \"./../common/SelfAuthorized.sol\";\r\nimport {IERC165} from \"./../interfaces/IERC165.sol\";\r\nimport {IModuleManager} from \"./../interfaces/IModuleManager.sol\";\r\nimport {Enum} from \"./../libraries/Enum.sol\";\r\nimport {Executor} from \"./Executor.sol\";\r\n\r\n/**\r\n * @title IModuleGuard Interface\r\n */\r\ninterface IModuleGuard is IERC165 {\r\n    /**\r\n     * @notice Checks the module transaction details.\r\n     * @dev The function needs to implement module transaction validation logic.\r\n     * @param to The address to which the transaction is intended.\r\n     * @param value The value of the transaction in Wei.\r\n     * @param data The transaction data.\r\n     * @param operation The type of operation of the module transaction.\r\n     * @param module The module involved in the transaction.\r\n     * @return moduleTxHash The hash of the module transaction.\r\n     */\r\n    function checkModuleTransaction(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation,\r\n        address module\r\n    ) external returns (bytes32 moduleTxHash);\r\n\r\n    /**\r\n     * @notice Checks after execution of module transaction.\r\n     * @dev The function needs to implement a check after the execution of the module transaction.\r\n     * @param txHash The hash of the module transaction.\r\n     * @param success The status of the module transaction execution.\r\n     */\r\n    function checkAfterModuleExecution(bytes32 txHash, bool success) external;\r\n}\r\n\r\nabstract contract BaseModuleGuard is IModuleGuard {\r\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\r\n        return\r\n            interfaceId == type(IModuleGuard).interfaceId || // 0x58401ed8\r\n            interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\r\n    }\r\n}\r\n\r\n/**\r\n * @title Module Manager - A contract managing Safe modules\r\n * @notice Modules are extensions with unlimited access to a Safe that can be added to a Safe by its owners.\r\n *         ⚠️ WARNING: Modules are a security risk since they can execute arbitrary transactions,\r\n *         so only trusted and audited modules should be added to a Safe. A malicious module can\r\n *         completely takeover a Safe.\r\n * @author Stefan George - @Georgi87\r\n * @author Richard Meissner - @rmeissner\r\n */\r\nabstract contract ModuleManager is SelfAuthorized, Executor, IModuleManager {\r\n    // SENTINEL_MODULES is used to traverse `modules`, so that:\r\n    //      1. `modules[SENTINEL_MODULES]` contains the first module\r\n    //      2. `modules[last_module]` points back to SENTINEL_MODULES\r\n    address internal constant SENTINEL_MODULES = address(0x1);\r\n\r\n    // keccak256(\"module_manager.module_guard.address\")\r\n    bytes32 internal constant MODULE_GUARD_STORAGE_SLOT = 0xb104e0b93118902c651344349b610029d694cfdec91c589c91ebafbcd0289947;\r\n\r\n    mapping(address => address) internal modules;\r\n\r\n    /**\r\n     * @notice Setup function sets the initial storage of the contract.\r\n     *         Optionally executes a delegate call to another contract to setup the modules.\r\n     * @param to Optional destination address of the call to execute.\r\n     * @param data Optional data of call to execute.\r\n     */\r\n    function setupModules(address to, bytes memory data) internal {\r\n        if (modules[SENTINEL_MODULES] != address(0)) revertWithError(\"GS100\");\r\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\r\n        if (to != address(0)) {\r\n            if (!isContract(to)) revertWithError(\"GS002\");\r\n            // Setup has to complete successfully or the transaction fails.\r\n            if (!execute(to, 0, data, Enum.Operation.DelegateCall, type(uint256).max)) revertWithError(\"GS000\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Runs pre-execution checks for module transactions if a guard is enabled.\r\n     * @param to Target address of module transaction.\r\n     * @param value Ether value of module transaction.\r\n     * @param data Data payload of module transaction.\r\n     * @param operation Operation type of module transaction.\r\n     * @return guard Guard to be used for checking.\r\n     * @return guardHash Hash returned from the guard tx check.\r\n     */\r\n    function preModuleExecution(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation\r\n    ) internal returns (address guard, bytes32 guardHash) {\r\n        onBeforeExecTransactionFromModule(to, value, data, operation);\r\n        guard = getModuleGuard();\r\n\r\n        // Only whitelisted modules are allowed.\r\n        if (msg.sender == SENTINEL_MODULES || modules[msg.sender] == address(0)) revertWithError(\"GS104\");\r\n\r\n        if (guard != address(0)) {\r\n            guardHash = IModuleGuard(guard).checkModuleTransaction(to, value, data, operation, msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Runs post-execution checks for module transactions if a guard is enabled.\r\n     * @param guardHash Hash returned from the guard during pre execution check.\r\n     * @param success Boolean flag indicating if the call succeeded.\r\n     * @param guard Guard to be used for checking.\r\n     * @dev Emits event based on module transaction success.\r\n     */\r\n    function postModuleExecution(address guard, bytes32 guardHash, bool success) internal {\r\n        if (guard != address(0)) {\r\n            IModuleGuard(guard).checkAfterModuleExecution(guardHash, success);\r\n        }\r\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\r\n        else emit ExecutionFromModuleFailure(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IModuleManager\r\n     */\r\n    function enableModule(address module) public override authorized {\r\n        // Module address cannot be null or sentinel.\r\n        if (module == address(0) || module == SENTINEL_MODULES) revertWithError(\"GS101\");\r\n        // Module cannot be added twice.\r\n        if (modules[module] != address(0)) revertWithError(\"GS102\");\r\n        modules[module] = modules[SENTINEL_MODULES];\r\n        modules[SENTINEL_MODULES] = module;\r\n        emit EnabledModule(module);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IModuleManager\r\n     */\r\n    function disableModule(address prevModule, address module) public override authorized {\r\n        // Validate module address and check that it corresponds to module index.\r\n        if (module == address(0) || module == SENTINEL_MODULES) revertWithError(\"GS101\");\r\n        if (modules[prevModule] != module) revertWithError(\"GS103\");\r\n        modules[prevModule] = modules[module];\r\n        modules[module] = address(0);\r\n        emit DisabledModule(module);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IModuleManager\r\n     */\r\n    function execTransactionFromModule(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation\r\n    ) external override returns (bool success) {\r\n        (address guard, bytes32 guardHash) = preModuleExecution(to, value, data, operation);\r\n        success = execute(to, value, data, operation, type(uint256).max);\r\n        postModuleExecution(guard, guardHash, success);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IModuleManager\r\n     */\r\n    function execTransactionFromModuleReturnData(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation\r\n    ) external override returns (bool success, bytes memory returnData) {\r\n        (address guard, bytes32 guardHash) = preModuleExecution(to, value, data, operation);\r\n        success = execute(to, value, data, operation, type(uint256).max);\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Load free memory location\r\n            returnData := mload(0x40)\r\n            // We allocate memory for the return data by setting the free memory location to\r\n            // current free memory location + data size + 32 bytes for data size value\r\n            mstore(0x40, add(returnData, add(returndatasize(), 0x20)))\r\n            // Store the size\r\n            mstore(returnData, returndatasize())\r\n            // Store the data\r\n            returndatacopy(add(returnData, 0x20), 0, returndatasize())\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n        postModuleExecution(guard, guardHash, success);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IModuleManager\r\n     */\r\n    function isModuleEnabled(address module) public view override returns (bool) {\r\n        return SENTINEL_MODULES != module && modules[module] != address(0);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IModuleManager\r\n     */\r\n    function getModulesPaginated(address start, uint256 pageSize) external view override returns (address[] memory array, address next) {\r\n        if (start != SENTINEL_MODULES && !isModuleEnabled(start)) revertWithError(\"GS105\");\r\n        if (pageSize == 0) revertWithError(\"GS106\");\r\n        // Init array with max page size\r\n        array = new address[](pageSize);\r\n\r\n        // Populate return array\r\n        uint256 moduleCount = 0;\r\n        next = modules[start];\r\n        while (next != address(0) && next != SENTINEL_MODULES && moduleCount < pageSize) {\r\n            array[moduleCount] = next;\r\n            next = modules[next];\r\n            ++moduleCount;\r\n        }\r\n\r\n        /**\r\n          Because of the argument validation, we can assume that the loop will always iterate over the valid module list values\r\n          and the `next` variable will either be an enabled module or a sentinel address (signalling the end). \r\n          \r\n          If we haven't reached the end inside the loop, we need to set the next pointer to the last element of the modules array\r\n          because the `next` variable (which is a module by itself) acting as a pointer to the start of the next page is neither \r\n          included to the current page, nor will it be included in the next one if you pass it as a start.\r\n        */\r\n        if (next != SENTINEL_MODULES) {\r\n            next = array[moduleCount - 1];\r\n        }\r\n        // Set the correct size of the returned array\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(array, moduleCount)\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n    }\r\n\r\n    /**\r\n     * @notice Returns true if `account` is a contract.\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     *      as the code is not created until after the constructor finishes.\r\n     * @param account The address being queried\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IModuleManager\r\n     */\r\n    function setModuleGuard(address moduleGuard) external override authorized {\r\n        if (moduleGuard != address(0) && !IModuleGuard(moduleGuard).supportsInterface(type(IModuleGuard).interfaceId))\r\n            revertWithError(\"GS301\");\r\n\r\n        bytes32 slot = MODULE_GUARD_STORAGE_SLOT;\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            sstore(slot, moduleGuard)\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n        emit ChangedModuleGuard(moduleGuard);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal method to retrieve the current module guard\r\n     * @return moduleGuard The address of the guard\r\n     */\r\n    function getModuleGuard() internal view returns (address moduleGuard) {\r\n        bytes32 slot = MODULE_GUARD_STORAGE_SLOT;\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            moduleGuard := sload(slot)\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n    }\r\n\r\n    /**\r\n     * @notice A hook that gets called before execution of {execTransactionFromModule*} methods.\r\n     * @param to Destination address of module transaction.\r\n     * @param value Ether value of module transaction.\r\n     * @param data Data payload of module transaction.\r\n     * @param operation Operation type of module transaction.\r\n     */\r\n    function onBeforeExecTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation) internal virtual {}\r\n}\r\n"
      },
      "project/contracts/common/SelfAuthorized.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {ErrorMessage} from \"../libraries/ErrorMessage.sol\";\r\n\r\n/**\r\n * @title SelfAuthorized - Authorizes current contract to perform actions to itself.\r\n * @author Richard Meissner - @rmeissner\r\n */\r\nabstract contract SelfAuthorized is ErrorMessage {\r\n    function requireSelfCall() private view {\r\n        if (msg.sender != address(this)) revertWithError(\"GS031\");\r\n    }\r\n\r\n    modifier authorized() {\r\n        // Modifiers are copied around during compilation. This is a function call as it minimized the bytecode size\r\n        requireSelfCall();\r\n        _;\r\n    }\r\n}\r\n"
      },
      "project/contracts/examples/guards/BaseGuard.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\nimport {BaseTransactionGuard, ITransactionGuard} from \"./../../base/GuardManager.sol\";\r\nimport {BaseModuleGuard, IModuleGuard} from \"./../../base/ModuleManager.sol\";\r\nimport {IERC165} from \"./../../interfaces/IERC165.sol\";\r\n\r\n/**\r\n * @title BaseGuard - Inherits BaseTransactionGuard and BaseModuleGuard.\r\n */\r\nabstract contract BaseGuard is BaseTransactionGuard, BaseModuleGuard {\r\n    /**\r\n     * @inheritdoc IERC165\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view virtual override(BaseTransactionGuard, BaseModuleGuard) returns (bool) {\r\n        return\r\n            interfaceId == type(ITransactionGuard).interfaceId || // 0xe6d7a83a\r\n            interfaceId == type(IModuleGuard).interfaceId || // 0x58401ed8\r\n            interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\r\n    }\r\n}\r\n"
      },
      "project/contracts/examples/guards/DebugTransactionGuard.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {ISafe} from \"./../../interfaces/ISafe.sol\";\r\nimport {Enum} from \"./../../libraries/Enum.sol\";\r\nimport {BaseGuard} from \"./BaseGuard.sol\";\r\n\r\n/**\r\n * @title Debug Transaction Guard - Emits transaction events with extended information.\r\n * @dev This guard is only meant as a development tool and example\r\n * @author Richard Meissner - @rmeissner\r\n */\r\ncontract DebugTransactionGuard is BaseGuard {\r\n    // solhint-disable-next-line payable-fallback\r\n    fallback() external {\r\n        // We don't revert on fallback to avoid issues in case of a Safe upgrade\r\n        // E.g. The expected check method might change and then the Safe would be locked.\r\n    }\r\n\r\n    event TransactionDetails(\r\n        address indexed safe,\r\n        bytes32 indexed txHash,\r\n        address to,\r\n        uint256 value,\r\n        bytes data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        bool usesRefund,\r\n        uint256 nonce,\r\n        bytes signatures,\r\n        address executor\r\n    );\r\n\r\n    event ModuleTransactionDetails(bytes32 indexed txHash, address to, uint256 value, bytes data, Enum.Operation operation, address module);\r\n\r\n    event GasUsage(address indexed safe, bytes32 indexed txHash, uint256 indexed nonce, bool success);\r\n\r\n    mapping(bytes32 => uint256) public txNonces;\r\n\r\n    /**\r\n     * @notice Called by the Safe contract before a transaction is executed.\r\n     * @param to Destination address of Safe transaction.\r\n     * @param value Ether value of Safe transaction.\r\n     * @param data Data payload of Safe transaction.\r\n     * @param operation Operation type of Safe transaction.\r\n     * @param safeTxGas Gas that should be used for the Safe transaction.\r\n     * @param baseGas Gas costs that are independent of the transaction execution (e.g. base transaction fee, signature check, payment of the refund)\r\n     * @param gasPrice Gas price that should be used for the payment calculation.\r\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n     * @param signatures Signature data that should be verified. Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\r\n     * @param executor Account executing the transaction.\r\n     */\r\n    function checkTransaction(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        // solhint-disable-next-line no-unused-vars\r\n        address payable refundReceiver,\r\n        bytes memory signatures,\r\n        address executor\r\n    ) external override {\r\n        uint256 nonce;\r\n        bytes32 txHash;\r\n        {\r\n            ISafe safe = ISafe(payable(msg.sender));\r\n            nonce = safe.nonce() - 1;\r\n            txHash = safe.getTransactionHash(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, nonce);\r\n        }\r\n        emit TransactionDetails(msg.sender, txHash, to, value, data, operation, safeTxGas, gasPrice > 0, nonce, signatures, executor);\r\n        txNonces[txHash] = nonce;\r\n    }\r\n\r\n    /**\r\n     * @notice Called by the Safe contract after a transaction is executed.\r\n     * @param txHash Hash of the executed transaction.\r\n     * @param success True if the transaction was successful.\r\n     */\r\n    function checkAfterExecution(bytes32 txHash, bool success) external override {\r\n        uint256 nonce = txNonces[txHash];\r\n        require(nonce != 0, \"Could not get nonce\");\r\n        txNonces[txHash] = 0;\r\n        emit GasUsage(msg.sender, txHash, nonce, success);\r\n    }\r\n\r\n    /**\r\n     * @notice Called by the Safe contract before a transaction is executed via a module.\r\n     * @param to Destination address of Safe transaction.\r\n     * @param value Ether value of Safe transaction.\r\n     * @param data Data payload of Safe transaction.\r\n     * @param operation Operation type of Safe transaction.\r\n     * @param module Account executing the transaction.\r\n     * @return moduleTxHash Hash of the module transaction.\r\n     */\r\n    function checkModuleTransaction(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation,\r\n        address module\r\n    ) external override returns (bytes32 moduleTxHash) {\r\n        moduleTxHash = keccak256(abi.encodePacked(to, value, data, operation, module));\r\n\r\n        emit ModuleTransactionDetails(moduleTxHash, to, value, data, operation, module);\r\n    }\r\n\r\n    /**\r\n     * @notice Called by the Safe contract after a module transaction is executed.\r\n     * @dev No-op.\r\n     */\r\n    function checkAfterModuleExecution(bytes32 txHash, bool success) external override {}\r\n}\r\n"
      },
      "project/contracts/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/// @notice More details at https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by `interfaceId`.\r\n     * See the corresponding EIP section\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n"
      },
      "project/contracts/interfaces/IFallbackManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title IFallbackManager - A contract interface managing fallback calls made to this contract.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IFallbackManager {\r\n    event ChangedFallbackHandler(address indexed handler);\r\n\r\n    /**\r\n     * @notice Set Fallback Handler to `handler` for the Safe.\r\n     * @dev 1. Only fallback calls without value and with data will be forwarded.\r\n     *      2. Changing the fallback handler can only be done via a Safe transaction.\r\n     *      3. Cannot be set to the Safe itself.\r\n     *      4. IMPORTANT! SECURITY RISK! The fallback handler can be set to any address and all the calls will be forwarded to it,\r\n     *         bypassing all the Safe's access control mechanisms. When setting the fallback handler, make sure to check the address\r\n     *         is a trusted contract and if it supports state changes, it implements the necessary checks.\r\n     * @param handler contract to handle fallback calls.\r\n     */\r\n    function setFallbackHandler(address handler) external;\r\n\r\n    /**\r\n     * @notice Forwards all calls to the fallback handler if set.\r\n     *         Returns empty data if no handler is set.\r\n     * @dev Appends the non-padded caller address to the calldata to be optionally used in the handler\r\n     *      The handler can make use of {HandlerContext} to extract the address.\r\n     *      This is done because in the next call frame the `msg.sender` will be {FallbackManager}'s address\r\n     *      and having the original caller address may enable additional verification scenarios.\r\n     */\r\n    fallback() external;\r\n}\r\n"
      },
      "project/contracts/interfaces/IGuardManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\n/* solhint-disable one-contract-per-file */\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title IGuardManager - A contract interface managing transaction guards which perform pre and post-checks on Safe transactions.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IGuardManager {\r\n    event ChangedGuard(address indexed guard);\r\n\r\n    /**\r\n     * @dev Set a guard that checks transactions before execution\r\n     *      This can only be done via a Safe transaction.\r\n     *      ⚠️ IMPORTANT: Since a guard has full power to block Safe transaction execution,\r\n     *        a broken guard can cause a denial of service for the Safe. Make sure to carefully\r\n     *        audit the guard code and design recovery mechanisms.\r\n     * @notice Set Transaction Guard `guard` for the Safe. Make sure you trust the guard.\r\n     * @param guard The address of the guard to be used or the 0 address to disable the guard\r\n     */\r\n    function setGuard(address guard) external;\r\n}\r\n"
      },
      "project/contracts/interfaces/IModuleManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\nimport {Enum} from \"../libraries/Enum.sol\";\r\n\r\n/**\r\n * @title IModuleManager - An interface of contract managing Safe modules\r\n * @notice Modules are extensions with unlimited access to a Safe that can be added to a Safe by its owners.\r\n           ⚠️ WARNING: Modules are a security risk since they can execute arbitrary transactions, \r\n           so only trusted and audited modules should be added to a Safe. A malicious module can\r\n           completely takeover a Safe.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IModuleManager {\r\n    event EnabledModule(address indexed module);\r\n    event DisabledModule(address indexed module);\r\n    event ExecutionFromModuleSuccess(address indexed module);\r\n    event ExecutionFromModuleFailure(address indexed module);\r\n    event ChangedModuleGuard(address indexed moduleGuard);\r\n\r\n    /**\r\n     * @notice Enables the module `module` for the Safe.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param module Module to be whitelisted.\r\n     */\r\n    function enableModule(address module) external;\r\n\r\n    /**\r\n     * @notice Disables the module `module` for the Safe.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param prevModule Previous module in the modules linked list.\r\n     * @param module Module to be removed.\r\n     */\r\n    function disableModule(address prevModule, address module) external;\r\n\r\n    /**\r\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token)\r\n     * @param to Destination address of module transaction.\r\n     * @param value Ether value of module transaction.\r\n     * @param data Data payload of module transaction.\r\n     * @param operation Operation type of module transaction.\r\n     * @return success Boolean flag indicating if the call succeeded.\r\n     */\r\n    function execTransactionFromModule(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation\r\n    ) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token) and return data\r\n     * @param to Destination address of module transaction.\r\n     * @param value Ether value of module transaction.\r\n     * @param data Data payload of module transaction.\r\n     * @param operation Operation type of module transaction.\r\n     * @return success Boolean flag indicating if the call succeeded.\r\n     * @return returnData Data returned by the call.\r\n     */\r\n    function execTransactionFromModuleReturnData(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation\r\n    ) external returns (bool success, bytes memory returnData);\r\n\r\n    /**\r\n     * @notice Returns if a module is enabled\r\n     * @return True if the module is enabled\r\n     */\r\n    function isModuleEnabled(address module) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns an array of modules.\r\n     *         If all entries fit into a single page, the next pointer will be 0x1.\r\n     *         If another page is present, next will be the last element of the returned array.\r\n     * @param start Start of the page. Has to be a module or start pointer (0x1 address)\r\n     * @param pageSize Maximum number of modules that should be returned. Has to be > 0\r\n     * @return array Array of modules.\r\n     * @return next Start of the next page.\r\n     */\r\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next);\r\n\r\n    /**\r\n     * @dev Set a module guard that checks transactions initiated by the module before execution\r\n     *      This can only be done via a Safe transaction.\r\n     *      ⚠️ IMPORTANT: Since a module guard has full power to block Safe transaction execution initiated via a module,\r\n     *        a broken module guard can cause a denial of service for the Safe modules. Make sure to carefully\r\n     *        audit the module guard code and design recovery mechanisms.\r\n     * @notice Set Module Guard `moduleGuard` for the Safe. Make sure you trust the module guard.\r\n     * @param moduleGuard The address of the module guard to be used or the zero address to disable the module guard.\r\n     */\r\n    function setModuleGuard(address moduleGuard) external;\r\n}\r\n"
      },
      "project/contracts/interfaces/INativeCurrencyPaymentFallback.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title Native Currency Payment Fallback Interface\r\n * @notice An interface to a contract that can receive native currency payments.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface INativeCurrencyPaymentFallback {\r\n    event SafeReceived(address indexed sender, uint256 value);\r\n\r\n    /**\r\n     * @notice Receive function accepts native currency transactions.\r\n     * @dev Emits an event with sender and received value.\r\n     */\r\n    receive() external payable;\r\n}\r\n"
      },
      "project/contracts/interfaces/IOwnerManager.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title IOwnerManager - Interface for contract which manages Safe owners and a threshold to authorize transactions.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IOwnerManager {\r\n    event AddedOwner(address indexed owner);\r\n    event RemovedOwner(address indexed owner);\r\n    event ChangedThreshold(uint256 threshold);\r\n\r\n    /**\r\n     * @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param owner New owner address.\r\n     * @param _threshold New threshold.\r\n     */\r\n    function addOwnerWithThreshold(address owner, uint256 _threshold) external;\r\n\r\n    /**\r\n     * @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param prevOwner Owner that pointed to the owner to be removed in the linked list\r\n     * @param owner Owner address to be removed.\r\n     * @param _threshold New threshold.\r\n     */\r\n    function removeOwner(address prevOwner, address owner, uint256 _threshold) external;\r\n\r\n    /**\r\n     * @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param prevOwner Owner that pointed to the owner to be replaced in the linked list\r\n     * @param oldOwner Owner address to be replaced.\r\n     * @param newOwner New owner address.\r\n     */\r\n    function swapOwner(address prevOwner, address oldOwner, address newOwner) external;\r\n\r\n    /**\r\n     * @notice Changes the threshold of the Safe to `_threshold`.\r\n     * @dev This can only be done via a Safe transaction.\r\n     * @param _threshold New threshold.\r\n     */\r\n    function changeThreshold(uint256 _threshold) external;\r\n\r\n    /**\r\n     * @notice Returns the number of required confirmations for a Safe transaction aka the threshold.\r\n     * @return Threshold number.\r\n     */\r\n    function getThreshold() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns if `owner` is an owner of the Safe.\r\n     * @return Boolean if `owner` is an owner of the Safe.\r\n     */\r\n    function isOwner(address owner) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns a list of Safe owners.\r\n     * @return Array of Safe owners.\r\n     */\r\n    function getOwners() external view returns (address[] memory);\r\n}\r\n"
      },
      "project/contracts/interfaces/ISafe.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {Enum} from \"./../libraries/Enum.sol\";\r\nimport {IFallbackManager} from \"./IFallbackManager.sol\";\r\nimport {IGuardManager} from \"./IGuardManager.sol\";\r\nimport {IModuleManager} from \"./IModuleManager.sol\";\r\nimport {INativeCurrencyPaymentFallback} from \"./INativeCurrencyPaymentFallback.sol\";\r\nimport {IOwnerManager} from \"./IOwnerManager.sol\";\r\nimport {IStorageAccessible} from \"./IStorageAccessible.sol\";\r\n\r\n/**\r\n * @title ISafe - A multisignature wallet interface with support for confirmations using signed messages based on EIP-712.\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface ISafe is INativeCurrencyPaymentFallback, IModuleManager, IGuardManager, IOwnerManager, IFallbackManager, IStorageAccessible {\r\n    event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);\r\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\r\n    event SignMsg(bytes32 indexed msgHash);\r\n    event ExecutionFailure(bytes32 indexed txHash, uint256 payment);\r\n    event ExecutionSuccess(bytes32 indexed txHash, uint256 payment);\r\n\r\n    /**\r\n     * @notice Sets an initial storage of the Safe contract.\r\n     * @dev This method can only be called once.\r\n     *      If a proxy was created without setting up, anyone can call setup and claim the proxy.\r\n     *      This method emits a {SafeSetup} event with the setup parameters instead of reading from storage,\r\n     *      which may be inaccurate if the delegate call to `to` modifies the owners, threshold or fallback handler.\r\n     * @param _owners List of Safe owners.\r\n     * @param _threshold Number of required confirmations for a Safe transaction.\r\n     * @param to Contract address for optional delegate call.\r\n     * @param data Data payload for optional delegate call.\r\n     * @param fallbackHandler Handler for fallback calls to this contract\r\n     * @param paymentToken Token that should be used for the payment (0 is ETH)\r\n     * @param payment Value that should be paid\r\n     * @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)\r\n     */\r\n    function setup(\r\n        address[] calldata _owners,\r\n        uint256 _threshold,\r\n        address to,\r\n        bytes calldata data,\r\n        address fallbackHandler,\r\n        address paymentToken,\r\n        uint256 payment,\r\n        address payable paymentReceiver\r\n    ) external;\r\n\r\n    /** @notice Executes a `operation` {0: Call, 1: DelegateCall} transaction to `to` with `value` (Native Currency)\r\n     *          and pays `gasPrice` * `gasLimit` in `gasToken` token to `refundReceiver`.\r\n     * @dev The fees are always transferred, even if the user transaction fails.\r\n     *      This method doesn't perform any sanity check of the transaction, such as:\r\n     *      - if the contract at `to` address has code or not\r\n     *      - if the `gasToken` is a contract or not\r\n     *      It is the responsibility of the caller to perform such checks.\r\n     * @param to Destination address of Safe transaction.\r\n     * @param value Ether value of Safe transaction.\r\n     * @param data Data payload of Safe transaction.\r\n     * @param operation Operation type of Safe transaction.\r\n     * @param safeTxGas Gas that should be used for the Safe transaction.\r\n     * @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\r\n     * @param gasPrice Gas price that should be used for the payment calculation.\r\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n     * @param signatures Signature data that should be verified.\r\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\r\n     * @return success Boolean indicating transaction's success.\r\n     */\r\n    function execTransaction(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address payable refundReceiver,\r\n        bytes memory signatures\r\n    ) external payable returns (bool success);\r\n\r\n    /**\r\n     * @notice Checks whether the signature provided is valid for the provided data and hash and executor. Reverts otherwise.\r\n     * @param executor Address that executes the transaction.\r\n     *        ⚠️⚠️⚠️ Make sure that the executor address is a legitimate executor.\r\n     *        Incorrectly passed the executor might reduce the threshold by 1 signature. ⚠️⚠️⚠️\r\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\r\n     * @param signatures Signature data that should be verified.\r\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\r\n     */\r\n    function checkSignatures(address executor, bytes32 dataHash, bytes memory signatures) external view;\r\n\r\n    /**\r\n     * @notice Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.\r\n     * @dev Since the EIP-1271 does an external call, be mindful of reentrancy attacks.\r\n     * @param executor Address that executes the transaction.\r\n     *        ⚠️⚠️⚠️ Make sure that the executor address is a legitimate executor.\r\n     *        Incorrectly passed the executor might reduce the threshold by 1 signature. ⚠️⚠️⚠️\r\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\r\n     * @param signatures Signature data that should be verified.\r\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\r\n     * @param requiredSignatures Amount of required valid signatures.\r\n     */\r\n    function checkNSignatures(address executor, bytes32 dataHash, bytes memory signatures, uint256 requiredSignatures) external view;\r\n\r\n    /**\r\n     * @notice Marks hash `hashToApprove` as approved.\r\n     * @dev This can be used with a pre-approved hash transaction signature.\r\n     *      IMPORTANT: The approved hash stays approved forever. There's no revocation mechanism, so it behaves similarly to ECDSA signatures\r\n     * @param hashToApprove The hash to mark as approved for signatures that are verified by this contract.\r\n     */\r\n    function approveHash(bytes32 hashToApprove) external;\r\n\r\n    /**\r\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\r\n     * @return bytes32 The domain separator hash.\r\n     */\r\n    function domainSeparator() external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Returns transaction hash to be signed by owners.\r\n     * @param to Destination address.\r\n     * @param value Ether value.\r\n     * @param data Data payload.\r\n     * @param operation Operation type.\r\n     * @param safeTxGas Gas that should be used for the safe transaction.\r\n     * @param baseGas Gas costs for data used to trigger the safe transaction.\r\n     * @param gasPrice Maximum gas price that should be used for this transaction.\r\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\r\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\r\n     * @param _nonce Transaction nonce.\r\n     * @return Transaction hash.\r\n     */\r\n    function getTransactionHash(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address refundReceiver,\r\n        uint256 _nonce\r\n    ) external view returns (bytes32);\r\n\r\n    /**\r\n     * External getter function for state variables.\r\n     */\r\n\r\n    /**\r\n     * @notice Returns the version of the Safe contract.\r\n     * @return Version string.\r\n     */\r\n    // solhint-disable-next-line\r\n    function VERSION() external view returns (string memory);\r\n\r\n    /**\r\n     * @notice Returns the nonce of the Safe contract.\r\n     * @return Nonce.\r\n     */\r\n    function nonce() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns a uint if the messageHash is signed by the owner.\r\n     * @param messageHash Hash of message that should be checked.\r\n     * @return Number denoting if an owner signed the hash.\r\n     */\r\n    function signedMessages(bytes32 messageHash) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns a uint if the messageHash is approved by the owner.\r\n     * @param owner Owner address that should be checked.\r\n     * @param messageHash Hash of message that should be checked.\r\n     * @return Number denoting if an owner approved the hash.\r\n     */\r\n    function approvedHashes(address owner, bytes32 messageHash) external view returns (uint256);\r\n}\r\n"
      },
      "project/contracts/interfaces/IStorageAccessible.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title Storage Accessible Interface\r\n * @author @safe-global/safe-protocol\r\n */\r\ninterface IStorageAccessible {\r\n    /**\r\n     * @notice Reads `length` bytes of storage in the current contract\r\n     * @param offset The offset in the current contract's storage in words to start reading from.\r\n     * @param length The number of words (32 bytes) of data to read.\r\n     * @return The bytes that were read.\r\n     */\r\n    function getStorageAt(uint256 offset, uint256 length) external view returns (bytes memory);\r\n\r\n    /**\r\n     * @notice Performs a `DELEGATECALL` to a `targetContract` in the context of self.\r\n     * @dev Internally reverts execution to avoid side effects (making it effectively static).\r\n     *      This method reverts with data equal to `abi.encodePacked(uint256(success), uint256(response.length), bytes(response))`.\r\n     *      Specifically, the return data after a call to this method will be:\r\n     *      `success:uint256 || response.length:uint256 || response:bytes`.\r\n     * @param targetContract Address of the contract containing the code to execute.\r\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\r\n     */\r\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external;\r\n}\r\n"
      },
      "project/contracts/libraries/Enum.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title Enum - Collection of enums used in Safe Smart Account contracts.\r\n * @author @safe-global/safe-protocol\r\n */\r\nlibrary Enum {\r\n    enum Operation {\r\n        Call,\r\n        DelegateCall\r\n    }\r\n}\r\n"
      },
      "project/contracts/libraries/ErrorMessage.sol": {
        "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title Error Message - Contract which uses assembly to revert with a custom error message.\r\n * @author Shebin John - @remedcu\r\n * @notice The aim is to save gas using assembly to revert with a custom error message.\r\n */\r\nabstract contract ErrorMessage {\r\n    /**\r\n     * @notice Function which uses assembly to revert with the passed error message.\r\n     * @param error The error string to revert with.\r\n     * @dev Currently it is expected that the `error` string is at max 5 bytes of length. Ex: \"GSXXX\"\r\n     */\r\n    function revertWithError(bytes5 error) internal pure {\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x08c379a000000000000000000000000000000000000000000000000000000000) // Selector for method \"Error(string)\"\r\n            mstore(add(ptr, 0x04), 0x20) // String offset\r\n            mstore(add(ptr, 0x24), 0x05) // Revert reason length (5 bytes for bytes5)\r\n            mstore(add(ptr, 0x44), error) // Revert reason\r\n            revert(ptr, 0x64) // Revert data length is 4 bytes for selector + offset + error length + error.\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n    }\r\n}\r\n"
      }
    }
  }
}